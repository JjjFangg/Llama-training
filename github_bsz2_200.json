{"text": "<s><start> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <segment> <name>PD1</name> <description>Patient Additional Demographic</description> <elements> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.1</name> <description>Living Dependency</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.2</name> <description>Living Arrangement</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.3</name> <description>Patient Primary Facility</description> <datatype>XON</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.4</name> <description>Patient Primary Care Provider Name &amp; ID No.</description> <datatype>XCN</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.5</name> <description>Student Indicator</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.6</name> <description>Handicap</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.7</name> <description>Living Will Code</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.8</name> <description>Organ Donor Code</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.9</name> <description>Separate Bill</description> <datatype>ID</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.10</name> <description>Duplicate Patient</description> <datatype>CX</datatype>"}
{"text": "<s><start> #define YEAR 2013 #define STATUS \"release\" #ifndef ROOT_DIR #define ROOT_DIR \"..\" #endif #define BUILD_DIR ROOT_DIR + \"/build/NetBox/ #ifndef SOURCE_DIR #define SOURCE_DIR ROOT_DIR + \"/src/NetBox\" #endif #ifndef OUTPUT_DIR #define OUTPUT_DIR ROOT_DIR + \"/build\" #endif #ifndef BINARIES_DIR_FAR2 #define BINARIES_DIR_FAR2 BUILD_DIR + \"/Far2\" #endif #ifndef BINARIES_DIR_FAR3 #define BINARIES_DIR_FAR3 BUILD_DIR + \"/Far3\" #endif #ifndef PUTTY_SOURCE_DIR #define PUTTY_SOURCE_DIR \"C:/Program Files/Putty\" #endif #define FileSourceMain_Far2x86 BINARIES_DIR_FAR2 + \"/x86/NetBox.dll\" #define FileSourceMain_Far2x64 BINARIES_DIR_FAR2 + \"/x64/NetBox.dll\" #define FileSourceMain_Far3x86 BINARIES_DIR_FAR3 + \"/x86/NetBox.dll\" #define FileSourceMain_Far3x64 BINARIES_DIR_FAR3 + \"/x64/NetBox.dll\" #define FileSourceEng SOURCE_DIR + \"/NetBoxEng.lng\" #define FileSourceRus SOURCE_DIR + \"/NetBoxRus.lng\" #define FileSourceChangeLog ROOT_DIR + \"/ChangeLog\" #define FileSourceReadmeEng ROOT_DIR + \"/README.md\" #define FileSourceReadmeRu ROOT_DIR + \"/README.RU.md\" #define FileSourceLicense ROOT_DIR + \"/LICENSE.txt\" #define PluginSubDirName \"NetBox\" #define Major #define Minor #define Rev #define Build #expr ParseVersion(FileSourceMain_Far2x86, Major, Minor, Rev, Build) #define Version"}
{"text": "</field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.11</name> <description>Publicity Code</description> <datatype>CE</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.12</name> <description>Protection Indicator</description> <datatype>ID</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.13</name> <description>Protection Indicator Effective Date</description> <datatype>DT</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.14</name> <description>Place of Worship</description> <datatype>XON</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.15</name> <description>Advance Directive Code</description> <datatype>CE</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.16</name> <description>Immunization Registry Status</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.17</name> <description>Immunization Registry Status Effective Date</description> <datatype>DT</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.18</name> <description>Publicity Code Effective Date</description> <datatype>DT</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.19</name> <description>Military Branch</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1.20</name> <description>Military Rank/Grade</description> <datatype>IS</datatype> </field> <field minOccurs=\"0\" maxOccurs=\"0\"> <name>PD1."}
{"text": "Str(Major) + \".\" + Str(Minor) + (Rev > 0 ? \".\" + Str(Rev) : \"\") + \\ (STATUS != \"\" ? \" \" + STATUS : \"\") [Setup] AppId=netbox AppMutex=NetBox AppName=NetBox plugin for Far2/Far3 AppPublisher=Michael Lukashov AppPublisherURL=https://github.com/michaellukashov/Far-NetBox AppSupportURL=http://forum.farmanager.com/viewtopic.php?f=39&t=6638 AppUpdatesURL=http://plugring.farmanager.com/plugin.php?pid=859&l=en VersionInfoCompany=Michael Lukashov VersionInfoDescription=Setup for NetBox plugin for Far2/Far3 {#Version} VersionInfoVersion={#Major}.{#Minor}.{#Rev}.{#Build} VersionInfoTextVersion={#Version} VersionInfoCopyright=(c) 2011-{#YEAR} Michael Lukashov DefaultDirName={pf}\\Far Manager\\Plugins\\{#PluginSubDirName} UsePreviousAppDir=false DisableProgramGroupPage=true LicenseFile=licence.setup ; UninstallDisplayIcon={app}\\winscp.ico OutputDir={#OUTPUT_DIR} DisableStartupPrompt=yes AppVersion={#Version} AppVerName=NetBox plugin for Far2/Far3 {#Version} OutputBaseFilename=FarNetBox-{#Major}.{#Minor}.{#Rev}_Far2_Far3_x86_x64 Compression=lzma2/ultra SolidCompression=yes PrivilegesRequired=none Uninstallable=no MinVersion=5.1 DisableDirPage=yes ; AlwaysShowDirOnReadyPage=yes ArchitecturesInstallIn64BitMode=x64 [Types] Name: full; Description: \"Full installation\" ; Name: compact; Description: \"Compact installation\" Name: custom; Description: \"Custom installation\"; Flags: iscustom ; Languages: en ru [Components] Name: main_far2_x86; Description: \"NetBox for Far2/x8"}
{"text": "21</name> <description>Military Status</description> <datatype>IS</datatype> </field> </elements> </segment><s><start> { \"fpsLimit\": 60, \"preset\": \"basic\", \"background\": { \"color\": \"#0d47a1\", \"image\": \"\", \"position\": \"50% 50%\", \"repeat\": \"no-repeat\", \"size\": \"cover\" } }<s><start> The two classes `KinesisRecorder` and `KinesisFirehoseRecorder` allow you to interface with Amazon Kinesis Data Streams and Amazon Kinesis Data Firehose to stream analytics data for real-time processing. ## What is Amazon Kinesis Data Streams? [Amazon Kinesis Data Streams](http://aws.amazon.com/kinesis/) is a fully managed service for real-time processing of streaming data at massive scale. Amazon Kinesis can collect and process hundreds of terabytes of data per hour from hundreds of thousands of sources, so you can write applications that process information in real-time. With Amazon Kinesis applications, you can build real-time dashboards, capture exceptions and generate alerts, drive recommendations, and make other real-time business or operational decisions. You can also easily send data to other services such as Amazon Simple Storage Service, Amazon DynamoDB, and Amazon Redshift. The Kinesis Data Streams `KinesisRecorder` client lets you store your Kinesis requests on disk and then send them all at once using the [PutRecords](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html) API call of Kinesis. This is useful because many mobile applications that use Kinesis Data Streams will create multiple requests per second. Sending an individual request under `PutRecord` action could adversely impact battery life. Moreover, the requests could be lost if the device goes offline. Thus, using the high-level Kinesis Data Streams client for batching can preserve both battery life and data. ## What is Amazon Kinesis Data Firehose? [Amazon Kinesis Data Firehose](http://aws.amazon.com/kinesis/firehose/) is a fully managed service for delivering real-time streaming"}
{"text": "6\"; Types: full custom; check: IsFar2X86Installed Name: main_far2_x64; Description: \"NetBox for Far2/x64\"; Types: full custom; check: IsWin64 and IsFar3X64Installed Name: main_far3_x86; Description: \"NetBox for Far3/x86\"; Types: full custom; check: IsFar3X86Installed Name: main_far3_x64; Description: \"NetBox for Far3/x64\"; Types: full custom; check: IsWin64 and IsFar3X64Installed ; Name: pageant; Description: \"Pageant (SSH authentication agent)\"; Types: full ; Name: puttygen; Description: \"PuTTYgen (key generator)\"; Types: full [Files] Source: \"{#FileSourceMain_Far2x86}\"; DestName: \"NetBox.dll\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceMain_Far2x64}\"; DestName: \"NetBox.dll\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceMain_Far3x86}\"; DestName: \"NetBox.dll\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceMain_Far3x64}\"; DestName: \"NetBox.dll\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceEng}\"; DestName: \"NetBoxEng.lng\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceEng}\"; DestName: \"NetBoxEng.lng\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components"}
{"text": "data to destinations such as Amazon Simple Storage Service (Amazon S3) and Amazon Redshift. With Kinesis Data Firehose, you do not need to write any applications or manage any resources. You configure your data producers to send data to Firehose and it automatically delivers the data to the destination that you specified. The Amazon Kinesis Data Firehose `KinesisFirehoseRecorder` client lets you store your Kinesis Data Firehose requests on disk and then send them using the [PutRecordBatch](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) API call of Kinesis Data Firehose. For more information about Amazon Kinesis Data Firehose, see [Amazon Kinesis Data Firehose](http://docs.aws.amazon.com/firehose/latest/dev/what-is-this-service.html). ## Integrating Amazon Kinesis Set up AWS Mobile SDK components by including the following libraries in your `app/build.gradle` dependencies list. ```groovy dependencies { implementation 'com.amazonaws:aws-android-sdk-kinesis:2.15.+' implementation ('com.amazonaws:aws-android-sdk-mobile-client:2.15.+@aar') { transitive = true } } ``` * `aws-android-sdk-kinesis` library enables sending analytics to Amazon Kinesis. * `aws-android-sdk-mobile-client` library gives access to the AWS credentials provider and configurations. Add the following imports to the main activity of your app. ```java import com.amazonaws.mobileconnectors.kinesis.kinesisrecorder.*; import com.amazonaws.mobile.client.AWSMobileClient; import com.amazonaws.regions.Regions; ``` To use Kinesis Data Streams in an application, you must set the correct permissions. The following IAM policy allows the user to submit records to a specific data stream, which is identified by [ARN](http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html). ```json { \"Statement\": [{ \"Effect\": \"Allow\", \"Action\": \"kinesis:PutRecords\", \"Resource\": \"arn:aws:"}
{"text": ": main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceEng}\"; DestName: \"NetBoxEng.lng\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceEng}\"; DestName: \"NetBoxEng.lng\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceRus}\"; DestName: \"NetBoxRus.lng\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceRus}\"; DestName: \"NetBoxRus.lng\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceRus}\"; DestName: \"NetBoxRus.lng\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceRus}\"; DestName: \"NetBoxRus.lng\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceChangeLog}\"; DestName: \"ChangeLog\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceChangeLog}\"; DestName: \"ChangeLog\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceChangeLog}\"; DestName: \"ChangeLog\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceChangeLog}\"; DestName: \"ChangeLog\"; DestDir: \"{code:GetPlugin3X64Dir"}
{"text": "kinesis:us-west-2:111122223333:stream/mystream\" }] } ``` The following IAM policy allows the user to submit records to a specific Kinesis Data Firehose delivery stream. ```json { \"Statement\": [{ \"Effect\": \"Allow\", \"Action\": \"firehose:PutRecordBatch\", \"Resource\": \"arn:aws:firehose:us-west-2:111122223333:deliverystream/mystream\" }] } ``` This policy should be applied to roles assigned to the Amazon Cognito identity pool, but you need to replace the `Resource` value with the correct ARN for your Amazon Kinesis or Amazon Kinesis Data Firehose stream. You can apply policies at the [IAM console](https://console.aws.amazon.com/iam/). To learn more about IAM policies, see [Using IAM](http://docs.aws.amazon.com/IAM/latest/UserGuide/IAM_Introduction.html). To learn more about Amazon Kinesis Data Streams policies, see [Controlling Access to Amazon Kinesis Data Streams Resources with IAM](http://docs.aws.amazon.com/kinesis/latest/dev/kinesis-using-iam.html). To learn more about Amazon Kinesis Data Firehose policies, see [Controlling Access with Amazon Kinesis Data Firehose](http://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html). ## Working with the API You can use `AWSMobileClient` to setup the Cognito credentials that are required to authenticate your requests with Amazon Kinesis. ```java AWSMobileClient.getInstance().initialize(getApplicationContext(), new Callback<UserStateDetails>() { @Override public void onResult(UserStateDetails userStateDetails) { Log.i(\"INIT\", userStateDetails.getUserState().toString()); } @Override public void onError(Exception e) { Log.e(\"INIT\", \"Initialization error.\", e); } } ); ``` Once you have credentials, you can use `KinesisRecorder` with Amazon Kinesis. The following snippet creates a directory and instantiates the `KinesisRecorder` client: ```java String"}
{"text": "}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceReadmeEng}\"; DestName: \"README.md\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceReadmeEng}\"; DestName: \"README.md\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceReadmeEng}\"; DestName: \"README.md\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceReadmeEng}\"; DestName: \"README.md\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceReadmeRu}\"; DestName: \"README.RU.md\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceReadmeRu}\"; DestName: \"README.RU.md\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceReadmeRu}\"; DestName: \"README.RU.md\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceReadmeRu}\"; DestName: \"README.RU.md\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion Source: \"{#FileSourceLicense}\"; DestName: \"LICENSE.txt\"; DestDir: \"{code:GetPlugin2X86Dir}\"; Components: main_far2_x86; Flags: ignoreversion Source: \"{#FileSourceLicense}\"; Dest"}
{"text": "kinesisDirectory = \"YOUR_UNIQUE_DIRECTORY\"; KinesisRecorder recorder = new KinesisRecorder( myActivity.getDir(kinesisDirectory, 0), Regions.<YOUR-AWS-REGION>, AWSMobileClient.getInstance() ); // KinesisRecorder uses synchronous calls, so you shouldn't call KinesisRecorder methods on the main thread. ``` To use `KinesisFirehoseRecorder`, you need to pass the object in a directory where streaming data is saved. We recommend you use an app private directory because the data is not encrypted. ```java KinesisFirehoseRecorder firehoseRecorder = new KinesisFirehoseRecorder( context.getCachedDir(), Regions.<YOUR-AWS-REGION>, AWSMobileClient.getInstance()); ``` Configure Kinesis: You can configure `KinesisRecorder` or `KinesisFirehoseRecorder` through their properties: You can configure the maximum allowed storage via the `withMaxStorageSize()` method of `KinesisRecorderConfig`. You can retrieve the same information by getting the `KinesisRecorderConfig` object for the recorder and calling `getMaxStorageSize():` ```java KinesisRecorderConfig kinesisRecorderConfig = recorder.getKinesisRecorderConfig(); Long maxStorageSize = kinesisRecorderConfig.getMaxStorageSize(); // Do something with maxStorageSize ``` To check the number of bytes currently stored in the directory passed in to the `KinesisRecorder` constructor, call `getDiskBytesUsed()`: ```java Long bytesUsed = recorder.getDiskBytesUsed(); // Do something with bytesUsed ``` To see how much space the `KinesisRecorder` client is allowed to use, you can call `getDiskByteLimit()`. ```java Long byteLimit = recorder.getDiskByteLimit(); // Do something with byteLimit ``` With `KinesisRecorder` created and configured, you can use `saveRecord()` to save records and then send them in a batch. ```java recorder.saveRecord( \"MyData\".getBytes(), \"MyStreamName\"); recorder.submitAllRecords(); ``` For the `saveRecord()` request above to work, you would have to have created"}
{"text": "Name: \"LICENSE.txt\"; DestDir: \"{code:GetPlugin2X64Dir}\"; Components: main_far2_x64; Flags: ignoreversion Source: \"{#FileSourceLicense}\"; DestName: \"LICENSE.txt\"; DestDir: \"{code:GetPlugin3X86Dir}\"; Components: main_far3_x86; Flags: ignoreversion Source: \"{#FileSourceLicense}\"; DestName: \"LICENSE.txt\"; DestDir: \"{code:GetPlugin3X64Dir}\"; Components: main_far3_x64; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\LICENCE\"; DestDir: \"{code:GetPluginX86Dir}\\PuTTY\"; Components: main_x86 pageant puttygen; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\LICENCE\"; DestDir: \"{code:GetPluginX64Dir}\\PuTTY\"; Components: main_x64 pageant puttygen; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\putty.hlp\"; DestDir: \"{code:GetPluginX86Dir}\\PuTTY\"; Components: main_x86 pageant puttygen; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\putty.hlp\"; DestDir: \"{code:GetPluginX64Dir}\\PuTTY\"; Components: main_x64 pageant puttygen; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\pageant.exe\"; DestDir: \"{code:GetPluginX86Dir}\\PuTTY\"; Components: main_x86 pageant; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\pageant.exe\"; DestDir: \"{code:GetPluginX64Dir}\\PuTTY\"; Components: main_x64 pageant; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\puttygen.exe\"; DestDir: \"{code:GetPluginX86Dir}\\PuTTY\"; Components: main"}
{"text": "a stream named `MyStreamName`. You can create new streams in the [Amazon Kinesis console](https://console.aws.amazon.com/kinesis). If `submitAllRecords()` is called while the app is online, requests will be sent and removed from the disk. If `submitAllRecords()` is called while the app is offline, requests will be kept on disk until `submitAllRecords()` is called while online. This applies even if you lose your internet connection midway through a submit. So if you save ten requests, call `submitAllRecords()`, send five, and then lose the Internet connection, you have five requests left on disk. These remaining five will be sent the next time `submitAllRecords()` is invoked online. Here is a similar snippet for Amazon Kinesis Data Firehose: ```java // Start to save data, either a String or a byte array firehoseRecorder.saveRecord(\"Hello world!\\n\"); firehoseRecorder.saveRecord(\"Streaming data to Amazon S3 via Amazon Kinesis Data Firehose is easy.\\n\"); // Send previously saved data to Amazon Kinesis Data Firehose // Note: submitAllRecords() makes network calls, so wrap it in an AsyncTask. new AsyncTask<Void, Void, Void>() { @Override protected Void doInBackground(Void... v) { try { firehoseRecorder.submitAllRecords(); } catch (AmazonClientException ace) { // handle error } } }.execute(); ``` To learn more about working with Kinesis Data Streams, see the [Amazon Kinesis Data Streams resources](http://aws.amazon.com/kinesis/developer-resources/). To learn more about the Kinesis Data Streams classes, see the [class reference for KinesisRecorder](https://aws-amplify.github.io/aws-sdk-android/docs/reference/com/amazonaws/mobileconnectors/kinesis/kinesisrecorder/KinesisRecorder.html). To learn more about the Kinesis Data Firehose classes, see the [class reference for KinesisFirehoseRecorder](https://aws-amplify.github.io/aws-sdk-android/docs/reference/com/amazonaws/mobileconnectors/kinesis/"}
{"text": "_x86 puttygen; Flags: ignoreversion ; Source: \"{#PUTTY_SOURCE_DIR}\\puttygen.exe\"; DestDir: \"{code:GetPluginX64Dir}\\PuTTY\"; Components: main_x64 puttygen; Flags: ignoreversion [InstallDelete] [Code] var InputDirsPage: TInputDirWizardPage; function GetFar2X86InstallDir(): String; var InstallDir: String; begin if RegQueryStringValue(HKLM, 'Software\\Far2', 'InstallDir', InstallDir) or RegQueryStringValue(HKCU, 'Software\\Far2', 'InstallDir', InstallDir) then begin Result := InstallDir; end; end; function GetFar2X64InstallDir(): String; var InstallDir: String; begin if RegQueryStringValue(HKCU, 'Software\\Far2', 'InstallDir_x64', InstallDir) or RegQueryStringValue(HKLM, 'Software\\Far2', 'InstallDir_x64', InstallDir) then begin Result := InstallDir; end; end; function IsFar2X86Installed(): Boolean; begin Result := GetFar2X86InstallDir() <> ''; end; function IsFar2X64Installed(): Boolean; begin Result := GetFar2X64InstallDir() <> ''; end; function GetDefaultFar2X86Dir(): String; var InstallDir: String; begin InstallDir := GetFar2X86InstallDir(); if InstallDir <> '' then begin Result := AddBackslash(InstallDir) + 'Plugins\\{#PluginSubDirName}'; end else begin Result := ExpandConstant('{pf}\\Far2\\Plugins\\{#PluginSubDirName}'); end; end; function GetDefaultFar2X64Dir(): String; var InstallDir: String; begin InstallDir := GetFar2X64InstallDir(); if InstallDir <> '' then begin Result := AddBackslash(InstallDir) + 'Plugins\\{#PluginSubDirName}'; end else begin Result := ExpandConstant('{pf}\\Far2\\Plugins\\{#PluginSubDirName}'); end; end; function GetPlugin2X86Dir("}
{"text": "kinesisrecorder/KinesisFirehoseRecorder.html).<s><start> /// /// Copyright (c) 2016 Dropbox, Inc. All rights reserved. /// /// Auto-generated by Stone, do not modify. /// #import <Foundation/Foundation.h> #import \"DBSerializableProtocol.h\" @class DBTEAMPOLICIESSharedFolderJoinPolicy; NS_ASSUME_NONNULL_BEGIN #pragma mark - API Object /// /// The `SharedFolderJoinPolicy` union. /// /// Policy governing which shared folders a team member can join. /// /// This class implements the `DBSerializable` protocol (serialize and /// deserialize instance methods), which is required for all Obj-C SDK API route /// objects. /// @interface DBTEAMPOLICIESSharedFolderJoinPolicy : NSObject <DBSerializable, NSCopying> #pragma mark - Instance fields /// The `DBTEAMPOLICIESSharedFolderJoinPolicyTag` enum type represents the /// possible tag states with which the `DBTEAMPOLICIESSharedFolderJoinPolicy` /// union can exist. typedef NS_CLOSED_ENUM(NSInteger, DBTEAMPOLICIESSharedFolderJoinPolicyTag){ /// Team members can only join folders shared by teammates. DBTEAMPOLICIESSharedFolderJoinPolicyFromTeamOnly, /// Team members can join any shared folder, including those shared by users /// outside the team. DBTEAMPOLICIESSharedFolderJoinPolicyFromAnyone, /// (no description). DBTEAMPOLICIESSharedFolderJoinPolicyOther, }; /// Represents the union's current tag state. @property (nonatomic, readonly) DBTEAMPOLICIESSharedFolderJoinPolicyTag tag; #pragma mark - Constructors /// /// Initializes union class with tag state of \"from_team_only\". /// /// Description of the \"from_team_only\" tag state: Team members can only join /// folders shared by teammates. /// /// @return An initialized instance. /// - (instancetype)initWithFromTeamOnly; /// /// Initializes union class with tag state of \"from_anyone\". /// /// Description of the \"from_anyone\" tag state: Team members can join any shared /// folder, including those shared by"}
{"text": "Param: String): String; begin Result := InputDirsPage.Values[0]; end; function GetPlugin2X64Dir(Param: String): String; begin Result := InputDirsPage.Values[1]; end; function GetFar3X86InstallDir(): String; var InstallDir: String; begin if RegQueryStringValue(HKLM, 'Software\\Far Manager', 'InstallDir', InstallDir) or RegQueryStringValue(HKCU, 'Software\\Far Manager', 'InstallDir', InstallDir) then begin Result := InstallDir; end; end; function GetFar3X64InstallDir(): String; var InstallDir: String; begin if RegQueryStringValue(HKLM, 'Software\\Far Manager', 'InstallDir_x64', InstallDir) or RegQueryStringValue(HKCU, 'Software\\Far Manager', 'InstallDir_x64', InstallDir) then begin Result := InstallDir; end; end; function IsFar3X86Installed(): Boolean; begin Result := GetFar3X86InstallDir() <> ''; end; function IsFar3X64Installed(): Boolean; begin Result := GetFar3X64InstallDir() <> ''; end; function GetDefaultFar3X86Dir(): String; var InstallDir: String; begin InstallDir := GetFar3X86InstallDir(); if InstallDir <> '' then begin Result := AddBackslash(InstallDir) + 'Plugins\\{#PluginSubDirName}'; end else begin Result := ExpandConstant('{pf}\\Far Manager\\Plugins\\{#PluginSubDirName}'); end; end; function GetDefaultFar3X64Dir(): String; var InstallDir: String; begin InstallDir := GetFar3X64InstallDir(); if InstallDir <> '' then begin Result := AddBackslash(InstallDir) + 'Plugins\\{#PluginSubDirName}'; end else begin Result := ExpandConstant('{pf}\\Far Manager\\Plugins\\{#PluginSubDirName}'); end; end; function GetPlugin3X86Dir(Param: String): String; begin Result := InputDirsPage.Values[2]; end; function GetPlugin3X64Dir(Param: String): String; begin Result :="}
{"text": "users outside the team. /// /// @return An initialized instance. /// - (instancetype)initWithFromAnyone; /// /// Initializes union class with tag state of \"other\". /// /// @return An initialized instance. /// - (instancetype)initWithOther; - (instancetype)init NS_UNAVAILABLE; #pragma mark - Tag state methods /// /// Retrieves whether the union's current tag state has value \"from_team_only\". /// /// @return Whether the union's current tag state has value \"from_team_only\". /// - (BOOL)isFromTeamOnly; /// /// Retrieves whether the union's current tag state has value \"from_anyone\". /// /// @return Whether the union's current tag state has value \"from_anyone\". /// - (BOOL)isFromAnyone; /// /// Retrieves whether the union's current tag state has value \"other\". /// /// @return Whether the union's current tag state has value \"other\". /// - (BOOL)isOther; /// /// Retrieves string value of union's current tag state. /// /// @return A human-readable string representing the union's current tag state. /// - (NSString *)tagName; @end #pragma mark - Serializer Object /// /// The serialization class for the `DBTEAMPOLICIESSharedFolderJoinPolicy` /// union. /// @interface DBTEAMPOLICIESSharedFolderJoinPolicySerializer : NSObject /// /// Serializes `DBTEAMPOLICIESSharedFolderJoinPolicy` instances. /// /// @param instance An instance of the `DBTEAMPOLICIESSharedFolderJoinPolicy` /// API object. /// /// @return A json-compatible dictionary representation of the /// `DBTEAMPOLICIESSharedFolderJoinPolicy` API object. /// + (nullable NSDictionary<NSString *, id> *)serialize:(DBTEAMPOLICIESSharedFolderJoinPolicy *)instance; /// /// Deserializes `DBTEAMPOLICIESSharedFolderJoinPolicy` instances. /// /// @param dict A json-compatible dictionary representation of the /// `DBTEAMPOLICIESSharedFolderJoinPolicy` API object. /// /// @return An instantiation of the `DBTEAMPOLICIESSharedFolderJoinPolicy` /// object. /// + ("}
{"text": "InputDirsPage.Values[3]; end; procedure CreateTheWizardPage; begin // Input dirs InputDirsPage := CreateInputDirPage(wpSelectComponents, 'Select plugin location', 'Where plugin should be installed?', 'Plugin will be installed in the following folder(s).'#13#10#13#10 + 'To continue, click Next. If you would like to select a different folder, click Browse.', False, 'Plugin folder'); InputDirsPage.Add('Far2/x86 plugin location:'); InputDirsPage.Values[0] := GetDefaultFar2X86Dir(); InputDirsPage.Add('Far2/x64 plugin location:'); InputDirsPage.Values[1] := GetDefaultFar2X64Dir(); InputDirsPage.Add('Far3/x86 plugin location:'); InputDirsPage.Values[2] := GetDefaultFar3X86Dir(); InputDirsPage.Add('Far3/x64 plugin location:'); InputDirsPage.Values[3] := GetDefaultFar3X64Dir(); end; procedure SetupInputDirs(); begin InputDirsPage.Edits[0].Enabled := IsComponentSelected('main_far2_x86'); InputDirsPage.Buttons[0].Enabled := IsComponentSelected('main_far2_x86'); InputDirsPage.PromptLabels[0].Enabled := IsComponentSelected('main_far2_x86'); // InputDirsPage.Edits[1].Visible := IsWin64(); // InputDirsPage.Buttons[1].Visible := IsWin64(); // InputDirsPage.PromptLabels[1].Visible := IsWin64(); InputDirsPage.Edits[1].Enabled := IsComponentSelected('main_far2_x64'); InputDirsPage.Buttons[1].Enabled := IsComponentSelected('main_far2_x64'); InputDirsPage.PromptLabels[1].Enabled := IsComponentSelected('main_far2_x64'); InputDirsPage.Edits[2].Enabled := IsComponentSelected('main_far3_x86'); InputDirsPage.Buttons[2].Enabled"}
{"text": "DBTEAMPOLICIESSharedFolderJoinPolicy *)deserialize:(NSDictionary<NSString *, id> *)dict; @end NS_ASSUME_NONNULL_END<s><start> \ufeff/*********************************************************************** !!!!!! DO NOT MODIFY !!!!!! GacGen.exe Resource.xml This file is generated by Workflow compiler https://github.com/vczh-libraries ***********************************************************************/ #ifndef VCZH_WORKFLOW_COMPILER_GENERATED_DEMOREFLECTION #define VCZH_WORKFLOW_COMPILER_GENERATED_DEMOREFLECTION #include \"Demo.h\" #ifndef VCZH_DEBUG_NO_REFLECTION #include \"GacUIReflection.h\" #endif #if defined( _MSC_VER) #pragma warning(push) #pragma warning(disable:4250) #elif defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wparentheses-equality\" #elif defined(__clang__) #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wparentheses-equality\" #endif /*********************************************************************** Reflection ***********************************************************************/ namespace vl { namespace reflection { namespace description { #ifndef VCZH_DEBUG_NO_REFLECTION DECL_TYPE_INFO(::demo::MainWindow) DECL_TYPE_INFO(::demo::MainWindowConstructor) #endif extern bool LoadDemoTypes(); } } } #if defined( _MSC_VER) #pragma warning(pop) #elif defined(__GNUC__) #pragma GCC diagnostic pop #elif defined(__clang__) #pragma clang diagnostic pop #endif #endif<s><start> abcdef abc def hij klm nop qrs abcdef abc def hij tuv wxy z<s><start> cask \"font-cormorant-sc\" do version :latest sha256 :no_check # github.com/google/fonts/ was verified as official when first introduced to the cask url \"https://github.com/google/fonts/trunk/ofl/cormorantsc\", using: :svn,"}
{"text": ":= IsComponentSelected('main_far3_x86'); InputDirsPage.PromptLabels[2].Enabled := IsComponentSelected('main_far3_x86'); // InputDirsPage.Edits[3].Visible := IsWin64(); // InputDirsPage.Buttons[3].Visible := IsWin64(); // InputDirsPage.PromptLabels[3].Visible := IsWin64(); InputDirsPage.Edits[3].Enabled := IsComponentSelected('main_far3_x64'); InputDirsPage.Buttons[3].Enabled := IsComponentSelected('main_far3_x64'); InputDirsPage.PromptLabels[3].Enabled := IsComponentSelected('main_far3_x64'); end; function NextButtonClick(CurPageID: Integer): Boolean; begin if CurPageID = wpWelcome then begin // SetupComponents(); end else if CurPageID = wpSelectComponents then begin SetupInputDirs(); end else if CurPageID = InputDirsPage.ID then begin WizardForm.DirEdit.Text := InputDirsPage.Values[0]; end; Result := True; end; function BackButtonClick(CurPageID: Integer): Boolean; begin // MsgBox('CurPageID: ' + IntToStr(CurPageID), mbInformation, mb_Ok); if CurPageID = InputDirsPage.ID then begin // SetupComponents(); end; if CurPageID = wpReady then begin SetupInputDirs(); end; Result := True; end; procedure InitializeWizard(); begin // Custom wizard page CreateTheWizardPage; WizardForm.LicenseAcceptedRadio.Checked := True; end;<s><start> /* fre:ac - free audio converter * Copyright (C) 2001-2020 Robert Kausch <robert.kausch@freac.org> * * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License as * published by the Free Software Foundation, either version 2 of * the License, or (at your option) any later version. * * THIS PACKAGE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR * IMPLIED"}
{"text": "trust_cert: true name \"Cormorant SC\" homepage \"https://fonts.google.com/specimen/Cormorant+SC\" font \"CormorantSC-Bold.ttf\" font \"CormorantSC-Light.ttf\" font \"CormorantSC-Medium.ttf\" font \"CormorantSC-Regular.ttf\" font \"CormorantSC-SemiBold.ttf\" end<s><start> @comment $NetBSD: PLIST,v 1.5 2017/06/21 08:28:43 markd Exp $ share/texmf-dist/scripts/luaotfload/luaotfload-tool.lua share/texmf-dist/scripts/luaotfload/mkcharacters share/texmf-dist/scripts/luaotfload/mkglyphlist share/texmf-dist/scripts/luaotfload/mkimport share/texmf-dist/scripts/luaotfload/mkstatus share/texmf-dist/scripts/luaotfload/mktests share/texmf-dist/tex/luatex/luaotfload/fontloader-2017-02-11.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-basics-gen.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-basics-nod.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-basics.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-data-con.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-afk.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-cff.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-cid.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-con."}
{"text": "WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. */ #include <dialogs/config/configcomponent.h> #include <config.h> #include <resources.h> #ifdef __WIN32__ # include <smooth/init.win32.h> #endif using namespace BoCA; using namespace BoCA::AS; freac::ConfigComponentDialog::ConfigComponentDialog(Component *component) { BoCA::Config *config = BoCA::Config::Get(); BoCA::I18n *i18n = BoCA::I18n::Get(); i18n->SetContext(\"Configuration\"); layer = component->GetConfigurationLayer(); if (layer != NIL) { mainWnd = new Window(component->GetName(), Point(config->GetIntValue(Config::CategorySettingsID, Config::SettingsWindowPosXID, Config::SettingsWindowPosXDefault), config->GetIntValue(Config::CategorySettingsID, Config::SettingsWindowPosYID, Config::SettingsWindowPosYDefault)) + Point(60, 60), layer->GetSize() + Size(8, 73)); mainWnd->SetRightToLeft(i18n->IsActiveLanguageRightToLeft()); mainWnd_titlebar = new Titlebar(TB_CLOSEBUTTON); divbar = new Divider(39, OR_HORZ | OR_BOTTOM); btn_cancel = new Button(i18n->TranslateString(\"Cancel\"), Point(175, 29), Size()); btn_cancel->onAction.Connect(&ConfigComponentDialog::Cancel, this); btn_cancel->SetOrientation(OR_LOWERRIGHT); btn_ok = new Button(i18n->TranslateString(\"OK\"), btn_cancel->GetPosition() - Point(88, 0), Size()); btn_ok->onAction.Connect(&ConfigComponentDialog::OK, this); btn_ok->SetOrientation(OR_LOWERRIGHT); Add(mainWnd); mainWnd->Add(mainWnd_titlebar); mainWnd->Add(divbar);"}
{"text": "lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-def.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-dsp.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-gbn.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-ini.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-lua.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-map.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-ocl.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-one.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-onr.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-osd.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-ota.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-otc.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-oti.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-otj.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-otl.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-oto.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-otr.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-ots.lua share/texmf-dist/tex/luatex/luaotf"}
{"text": "mainWnd->Add(btn_ok); mainWnd->Add(btn_cancel); mainWnd->GetMainLayer()->Add(layer); mainWnd->SetFlags(mainWnd->GetFlags() | WF_NOTASKBUTTON | WF_MODAL); mainWnd->SetIcon(ImageLoader::Load(String(Config::Get()->resourcesPath).Append(\"icons/freac.png\"))); #ifdef __WIN32__ mainWnd->SetIconDirect(LoadImageA(hInstance, MAKEINTRESOURCEA(IDI_ICON), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED)); #endif } else { mainWnd = NIL; mainWnd_titlebar = NIL; btn_cancel = NIL; btn_ok = NIL; divbar = NIL; } } freac::ConfigComponentDialog::~ConfigComponentDialog() { if (layer == NIL) return; DeleteObject(mainWnd_titlebar); DeleteObject(mainWnd); DeleteObject(btn_ok); DeleteObject(btn_cancel); DeleteObject(divbar); } const Error &freac::ConfigComponentDialog::ShowDialog() { if (layer != NIL) mainWnd->WaitUntilClosed(); else error = Error(); return error; } Void freac::ConfigComponentDialog::OK() { if (layer->SaveSettings() == Error()) return; mainWnd->Close(); } Void freac::ConfigComponentDialog::Cancel() { mainWnd->Close(); }<s><start> --- record.c.orig 2001-08-14 20:10:46.000000000 +0800 +++ record.c 2011-09-05 15:09:11.000000000 +0800 @@ -31,14 +31,18 @@ ** May 25, 2000 Ver 1.0 */ -#include<stdio.h> -#include<fcntl.h> -#include<sys/types.h> -#include<pwd.h> -#include<ctype.h> -"}
{"text": "load/fontloader-font-oup.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-tfm.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-font-ttf.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts-demo-vf-1.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts-enc.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts-ext.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts-syn.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-fonts.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-l-boolean.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-file.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-function.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-io.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-lpeg.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-lua.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-math.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-string.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-l-table.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-languages.lua share/texmf-dist/tex/luatex"}
{"text": "#include<errno.h> +#include <sys/types.h> +#include <stdio.h> +#include <stdlib.h> +#include <unistd.h> +#include <sys/stat.h> +#include <fcntl.h> +#include <pwd.h> +#include <ctype.h> +#include <errno.h> -#include\"record.h\" +#include \"record.h\" +#include \"xjump.h\" #define FS '\\t' /* field separator */<s><start> <?php /** * Copyright \u00a9 Magento, Inc. All rights reserved. * See COPYING.txt for license details. */ namespace Magento\\Customer\\Controller\\Adminhtml\\Index; class Wishlist extends \\Magento\\Customer\\Controller\\Adminhtml\\Index { /** * Wishlist Action * * @return \\Magento\\Framework\\View\\Result\\Layout */ public function execute() { $customerId = $this->initCurrentCustomer(); $itemId = (int)$this->getRequest()->getParam('delete'); if ($customerId && $itemId) { try { $this->_objectManager->create(\\Magento\\Wishlist\\Model\\Item::class)->load($itemId)->delete(); } catch (\\Exception $exception) { $this->_objectManager->get(\\Psr\\Log\\LoggerInterface::class)->critical($exception); } } $resultLayout = $this->resultLayoutFactory->create(); return $resultLayout; } }<s><start> import { ChildProcessReporter } from '@integration/testing-tools'; import { serenity, StreamReporter } from '@serenity-js/core'; export = function () { this.setDefaultTimeout(5000); serenity.configure({ crew: [ new ChildProcessReporter(), new StreamReporter(), ], }); };<s><start> /* * linux/fs/super.c * * (C) 1991 Linus Torvalds */ /* * super.c contains code to handle the super-block tables. */ #include <linux/config.h> #include <linux/sched.h> #include <linux/kernel.h> #include <asm/system.h> #include <errno.h> #include <sys/stat.h"}
{"text": "/luaotfload/fontloader-languages.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-math.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-math.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-mplib.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-mplib.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-plain.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-preprocessor-test.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-preprocessor.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-preprocessor.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-reference.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-swiglib-test.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-swiglib-test.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-swiglib.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-swiglib.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-test.tex share/texmf-dist/tex/luatex/luaotfload/fontloader-util-fil.lua share/texmf-dist/tex/luatex/luaotfload/fontloader-util-str.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-auxiliary.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-blacklist.cnf share/texmf-dist/tex/luatex/luaotfload"}
{"text": "> int sync_dev(int dev); void wait_for_keypress(void); /* set_bit uses setb, as gas doesn't recognize setc */ #define set_bit(bitnr,addr) ({ \\ register int __res __asm__(\"ax\"); \\ __asm__(\"bt %2,%3;setb %%al\":\"=a\" (__res):\"a\" (0),\"r\" (bitnr),\"m\" (*(addr))); \\ __res; }) struct super_block super_block[NR_SUPER]; /* this is initialized in init/main.c */ int ROOT_DEV = 0; static void lock_super(struct super_block * sb) { cli(); while (sb->s_lock) sleep_on(&(sb->s_wait)); sb->s_lock = 1; sti(); } static void free_super(struct super_block * sb) { cli(); sb->s_lock = 0; wake_up(&(sb->s_wait)); sti(); } static void wait_on_super(struct super_block * sb) { cli(); while (sb->s_lock) sleep_on(&(sb->s_wait)); sti(); } struct super_block * get_super(int dev) { struct super_block * s; if (!dev) return NULL; s = 0+super_block; while (s < NR_SUPER+super_block) if (s->s_dev == dev) { wait_on_super(s); if (s->s_dev == dev) return s; s = 0+super_block; } else s++; return NULL; } void put_super(int dev) { struct super_block * sb; struct m_inode * inode; int i; if (dev == ROOT_DEV) { printk(\"root diskette changed: prepare for armageddon\\n\\r\"); return; } if (!(sb = get_super(dev))) return; if (sb->s_imount) { printk(\"Mounted disk changed - tssk, tssk\\n\\r\"); return; } lock_super(sb); sb->s_dev = 0; for(i=0;i<I_MAP_SLOTS;i++) brelse("}
{"text": "/luaotfload-characters.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-colors.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-configuration.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-database.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-diagnostics.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-features.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-glyphlist.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-init.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-letterspace.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-loaders.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-log.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-main.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-parsers.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-resolvers.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload-status.lua share/texmf-dist/tex/luatex/luaotfload/luaotfload.sty<s><start> --- sandbox/linux/BUILD.gn.orig 2019-04-08 08:18:26 UTC +++ sandbox/linux/BUILD.gn @@ -12,12 +12,12 @@ if (is_android) { } declare_args() { - compile_suid_client = is_linux + compile_suid_"}
{"text": "sb->s_imap[i]); for(i=0;i<Z_MAP_SLOTS;i++) brelse(sb->s_zmap[i]); free_super(sb); return; } static struct super_block * read_super(int dev) { struct super_block * s; struct buffer_head * bh; int i,block; if (!dev) return NULL; check_disk_change(dev); if (s = get_super(dev)) return s; for (s = 0+super_block ;; s++) { if (s >= NR_SUPER+super_block) return NULL; if (!s->s_dev) break; } s->s_dev = dev; s->s_isup = NULL; s->s_imount = NULL; s->s_time = 0; s->s_rd_only = 0; s->s_dirt = 0; lock_super(s); if (!(bh = bread(dev,1))) { s->s_dev=0; free_super(s); return NULL; } *((struct d_super_block *) s) = *((struct d_super_block *) bh->b_data); brelse(bh); if (s->s_magic != SUPER_MAGIC) { s->s_dev = 0; free_super(s); return NULL; } for (i=0;i<I_MAP_SLOTS;i++) s->s_imap[i] = NULL; for (i=0;i<Z_MAP_SLOTS;i++) s->s_zmap[i] = NULL; block=2; for (i=0 ; i < s->s_imap_blocks ; i++) if (s->s_imap[i]=bread(dev,block)) block++; else break; for (i=0 ; i < s->s_zmap_blocks ; i++) if (s->s_zmap[i]=bread(dev,block)) block++; else break; if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) { for(i=0;i<I_MAP_SLOTS;"}
{"text": "client = is_linux && !is_bsd - compile_credentials = is_linux + compile_credentials = is_linux && !is_bsd # On Android, use plain GTest. - use_base_test_suite = is_linux + use_base_test_suite = is_linux && !is_bsd } if (is_nacl_nonsfi) { @@ -379,7 +379,7 @@ component(\"sandbox_services\") { public_deps += [ \":sandbox_services_headers\" ] } - if (is_nacl_nonsfi) { + if (is_nacl_nonsfi || is_bsd) { cflags = [ \"-fgnu-inline-asm\" ] sources -= [ @@ -387,6 +387,8 @@ component(\"sandbox_services\") { \"services/init_process_reaper.h\", \"services/scoped_process.cc\", \"services/scoped_process.h\", + \"services/syscall_wrappers.cc\", + \"services/syscall_wrappers.h\", \"services/yama.cc\", \"services/yama.h\", \"syscall_broker/broker_channel.cc\", @@ -405,6 +407,10 @@ component(\"sandbox_services\") { \"syscall_broker/broker_process.h\", \"syscall_broker/broker_simple_message.cc\", \"syscall_broker/broker_simple_message.h\", + ] + sources += [ + \"services/libc_interceptor.cc\", + \"services/libc_interceptor.h\", ] } else if (!is_android) { sources += [<s><start> --recursive --require @babel/register<s><start> <HTML><HEAD> <TITLE>Invalid URL</TITLE> </HEAD><BODY> <H1>Invalid URL</H1> The requested URL \"&#91;no&#32;URL&#93;\", is invalid.<p> Reference&#32;&#35;9&#46;44952317&#46;1507271057&#4"}
{"text": "i++) brelse(s->s_imap[i]); for(i=0;i<Z_MAP_SLOTS;i++) brelse(s->s_zmap[i]); s->s_dev=0; free_super(s); return NULL; } s->s_imap[0]->b_data[0] |= 1; s->s_zmap[0]->b_data[0] |= 1; free_super(s); return s; } int sys_umount(char * dev_name) { struct m_inode * inode; struct super_block * sb; int dev; if (!(inode=namei(dev_name))) return -ENOENT; dev = inode->i_zone[0]; if (!S_ISBLK(inode->i_mode)) { iput(inode); return -ENOTBLK; } iput(inode); if (dev==ROOT_DEV) return -EBUSY; if (!(sb=get_super(dev)) || !(sb->s_imount)) return -ENOENT; if (!sb->s_imount->i_mount) printk(\"Mounted inode has i_mount=0\\n\"); for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++) if (inode->i_dev==dev && inode->i_count) return -EBUSY; sb->s_imount->i_mount=0; iput(sb->s_imount); sb->s_imount = NULL; iput(sb->s_isup); sb->s_isup = NULL; put_super(dev); sync_dev(dev); return 0; } int sys_mount(char * dev_name, char * dir_name, int rw_flag) { struct m_inode * dev_i, * dir_i; struct super_block * sb; int dev; if (!(dev_i=namei(dev_name))) return -ENOENT; dev = dev_i->i_zone[0]; if (!S_ISBLK(dev_i->i_mode)) { iput(dev_i); return"}
{"text": "6;135fad8 </BODY></HTML><s><start> var config = { type: Phaser.AUTO, parent: 'phaser-example', width: 800, height: 600, scene: { create: create }, }; var game = new Phaser.Game(config); function create() { var graphics = this.add.graphics(); drawStar(graphics, 100, 300, 4, 50, 50 / 2, 0xffff00, 0xff0000); drawStar(graphics, 400, 300, 5, 100, 100 / 2, 0xffff00, 0xff0000); drawStar(graphics, 700, 300, 6, 50, 50 / 2, 0xffff00, 0xff0000); } function drawStar (graphics, cx, cy, spikes, outerRadius, innerRadius, color, lineColor) { var rot = Math.PI / 2 * 3; var x = cx; var y = cy; var step = Math.PI / spikes; graphics.lineStyle(4, lineColor, 1); graphics.fillStyle(color, 1); graphics.beginPath(); graphics.moveTo(cx, cy - outerRadius); for (i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; graphics.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; graphics.lineTo(x, y); rot += step; } graphics.lineTo(cx, cy - outerRadius); graphics.closePath(); graphics.fillPath(); graphics.strokePath(); }<s><start> .theme-dusk,.theme-midnight { .hljs { display: block; overflow-x: auto; background: #232323; color: #e6e1dc; } .hljs-comment, .hljs-quote { color: #bc9458"}
{"text": "-EPERM; } iput(dev_i); if (!(dir_i=namei(dir_name))) return -ENOENT; if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) { iput(dir_i); return -EBUSY; } if (!S_ISDIR(dir_i->i_mode)) { iput(dir_i); return -EPERM; } if (!(sb=read_super(dev))) { iput(dir_i); return -EBUSY; } if (sb->s_imount) { iput(dir_i); return -EBUSY; } if (dir_i->i_mount) { iput(dir_i); return -EPERM; } sb->s_imount=dir_i; dir_i->i_mount=1; dir_i->i_dirt=1; /* NOTE! we don't iput(dir_i) */ return 0; /* we do that in umount */ } void mount_root(void) { int i,free; struct super_block * p; struct m_inode * mi; if (32 != sizeof (struct d_inode)) panic(\"bad i-node size\"); for(i=0;i<NR_FILE;i++) file_table[i].f_count=0; if (MAJOR(ROOT_DEV) == 2) { printk(\"Insert root floppy and press ENTER\"); wait_for_keypress(); } for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) { p->s_dev = 0; p->s_lock = 0; p->s_wait = NULL; } if (!(p=read_super(ROOT_DEV))) panic(\"Unable to mount root\"); if (!(mi=iget(ROOT_DEV,ROOT_INO))) panic(\"Unable to read root i-node\"); mi->i_count += 3 ; /* NOTE! it is logically used 4 times, not 1 */ p->s_isup = p->s_imount = mi; current->pwd = mi; current"}
{"text": "; font-style: italic; } .hljs-keyword, .hljs-selector-tag { color: #c26230; } .hljs-string, .hljs-number, .hljs-regexp, .hljs-variable, .hljs-template-variable { color: #a5c261; } .hljs-subst { color: #519f50; } .hljs-tag, .hljs-name { color: #e8bf6a; } .hljs-type { color: #da4939; } .hljs-symbol, .hljs-bullet, .hljs-built_in, .hljs-builtin-name, .hljs-attr, .hljs-link { color: #6d9cbe; } .hljs-params { color: #d0d0ff; } .hljs-attribute { color: #cda869; } .hljs-meta { color: #9b859d; } .hljs-title, .hljs-section { color: #ffc66d; } .hljs-addition { background-color: #144212; color: #e6e1dc; display: inline-block; width: 100%; } .hljs-deletion { background-color: #600; color: #e6e1dc; display: inline-block; width: 100%; } .hljs-selector-class { color: #9b703f; } .hljs-selector-id { color: #8b98ab; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; } .hljs-link { text-decoration: underline; } }<s><start> #ifndef CREATE_EMPTY_DIRECTED_GRAPH_WITH_GRAPH_NAME_H #define CREATE_EMPTY_DIRECTED_GRAPH_WITH_GRAPH_NAME_H #include <boost/graph/adjacency_list.hpp> boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS"}
{"text": "->root = mi; free=0; i=p->s_nzones; while (-- i >= 0) if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data)) free++; printk(\"%d/%d free blocks\\n\\r\",free,p->s_nzones); free=0; i=p->s_ninodes+1; while (-- i >= 0) if (!set_bit(i&8191,p->s_imap[i>>13]->b_data)) free++; printk(\"%d/%d free inodes\\n\\r\",free,p->s_ninodes); }<s><start> require 'brakeman/processors/lib/basic_processor' #Finds method calls matching the given target(s). # #-- This should be deprecated --# # #-- Do not use for new code --# # #Targets/methods can be: # # - nil: matches anything, including nothing # - Empty array: matches nothing # - Symbol: matches single target/method exactly # - Array of symbols: matches against any of the symbols # - Regular expression: matches the expression # - Array of regular expressions: matches any of the expressions # #If a target is also the name of a class, methods called on instances #of that class will also be matched, in a very limited way. #(Any methods called on Klass.new, basically. More useful when used #in conjunction with AliasProcessor.) # #Examples: # # #To find any uses of this class: # FindCall.new :FindCall, nil # # #Find system calls without a target # FindCall.new [], [:system, :exec, :syscall] # # #Find all calls to length(), no matter the target # FindCall.new nil, :length # # #Find all calls to sub, sub!, gsub, or gsub! # FindCall.new nil, /^g?sub!?$/ class Brakeman::FindCall < Brakeman::BasicProcessor def initialize targets, methods, tracker super tracker @calls = [] @find_targets = targets @find_methods = methods @current_class = nil @current_method = nil end #Returns a list of results. # #A result"}
{"text": ", boost::no_property, boost::no_property, boost::property<boost::graph_name_t, std::string>> create_empty_directed_graph_with_graph_name() noexcept; #endif // CREATE_EMPTY_DIRECTED_GRAPH_WITH_GRAPH_NAME_H<s><start> /* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.stanbol.entityhub.web.reader; import java.io.IOException; import java.io.InputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Type; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import javax.servlet.ServletContext; import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.HttpHeaders; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider; import org.apache.clerezza.commons.rdf"}
{"text": "looks like: # # s(:result, :ClassName, :method_name, s(:call, ...)) def matches @calls end #Process the given source. Provide either class and method being searched #or the template. These names are used when reporting results. # #Use FindCall#matches to retrieve results. def process_source exp process exp end #Process body of method def process_defn exp process_all exp.body end alias :process_defs :process_defn #Look for matching calls and add them to results def process_call exp target = get_target exp.target method = exp.method process_call_args exp if match(@find_targets, target) and match(@find_methods, method) @calls << Sexp.new(:result, @current_module, @current_class, @current_method, exp).line(exp.line) end exp end #Process an assignment like a call def process_attrasgn exp process_call exp end private #Gets the target of a call as a Symbol #if possible def get_target exp if sexp? exp case exp.node_type when :ivar, :lvar, :const, :lit exp.value when :colon2 class_name exp else exp end else exp end end #Checks if the search terms match the given item def match search_terms, item case search_terms when Symbol if search_terms == item true else false end when Enumerable if search_terms.empty? item == nil end end end end<s><start> /* * Copyright (c) 2004, 2014, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * * This code is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 only, as * published by the Free Software Foundation. Oracle designates this * particular file as subject to the \"Classpath\" exception as provided * by Oracle in the LICENSE file that accompanied this code. * * This code is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or * F"}
{"text": ".Graph; import org.apache.clerezza.commons.rdf.BlankNodeOrIRI; import org.apache.clerezza.commons.rdf.Triple; import org.apache.clerezza.commons.rdf.IRI; import org.apache.clerezza.rdf.core.serializedform.Parser; import org.apache.clerezza.rdf.core.serializedform.SupportedFormat; import org.apache.clerezza.rdf.core.serializedform.UnsupportedParsingFormatException; import org.apache.felix.scr.annotations.Component; import org.apache.felix.scr.annotations.Property; import org.apache.felix.scr.annotations.Reference; import org.apache.felix.scr.annotations.Service; import org.apache.stanbol.commons.indexedgraph.IndexedGraph; import org.apache.stanbol.entityhub.jersey.utils.JerseyUtils; import org.apache.stanbol.entityhub.jersey.utils.MessageBodyReaderUtils; import org.apache.stanbol.entityhub.jersey.utils.MessageBodyReaderUtils.RequestData; import org.apache.stanbol.entityhub.model.clerezza.RdfValueFactory; import org.apache.stanbol.entityhub.servicesapi.model.Representation; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * Provides support for reading Representation form Requests. This implementation * supports all RDF supports as well as {@link MediaType#APPLICATION_FORM_URLENCODED} * - in case the data are sent from an HTML form - and * {@link MediaType#MULTIPART_FORM_DATA} - mime encoded data. * In case of an HTML form the encoding need to be specified by the parameter * \"encoding\" for the entity data the parameters \"entity\" or \"content\" can be * used. * @author Rupert Westenthaler * */ @Component @Service(Object.class) @Property(name=\"javax.ws.rs\", boolValue=true) @Provider @Consumes({ //First the data types directly supported for parsing representations MediaType.APPLICATION_"}
{"text": "ITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License * version 2 for more details (a copy is included in the LICENSE file that * accompanied this code). * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. */ package sun.tools.jconsole; import java.awt.*; import java.awt.event.*; import java.io.*; import java.lang.management.*; import java.lang.reflect.*; import javax.swing.*; import javax.swing.border.*; import javax.swing.event.*; import java.util.*; import java.util.concurrent.*; import java.util.List; import static sun.tools.jconsole.Utilities.*; @SuppressWarnings(\"serial\") class ThreadTab extends Tab implements ActionListener, DocumentListener, ListSelectionListener { PlotterPanel threadMeter; TimeComboBox timeComboBox; JTabbedPane threadListTabbedPane; DefaultListModel<Long> listModel; JTextField filterTF; JLabel messageLabel; JSplitPane threadsSplitPane; HashMap<Long, String> nameCache = new HashMap<Long, String>(); private ThreadOverviewPanel overviewPanel; private boolean plotterListening = false; private static final String threadCountKey = \"threadCount\"; private static final String peakKey = \"peak\"; private static final Color threadCountColor = Plotter.defaultColor; private static final Color peakColor = Color.red; private static final Border thinEmptyBorder = new EmptyBorder(2, 2, 2, 2); /* Hierarchy of panels and layouts for this tab: ThreadTab (BorderLayout) North: topPanel (BorderLayout) Center: controlPanel (FlowLayout) timeComboBox Center: plotterPanel (BorderLayout) Center: plotter */ public static String getTabName() { return Messages.THREADS; } public ThreadTab(VMPanel vmPanel) { super(vmPanel, getTabName());"}
{"text": "JSON, SupportedFormat.N3, SupportedFormat.N_TRIPLE, SupportedFormat.RDF_XML, SupportedFormat.TURTLE, SupportedFormat.X_TURTLE, SupportedFormat.RDF_JSON, //finally this also supports sending the data as form and mime multipart MediaType.APPLICATION_FORM_URLENCODED, MediaType.MULTIPART_FORM_DATA}) public class RepresentationReader implements MessageBodyReader<Map<String,Representation>> { private static final Logger log = LoggerFactory.getLogger(RepresentationReader.class); public static final Set<String> supportedMediaTypes; private static final MediaType DEFAULT_ACCEPTED_MEDIA_TYPE = MediaType.TEXT_PLAIN_TYPE; static { Set<String> types = new HashSet<String>(); //ensure everything is lower case types.add(MediaType.APPLICATION_JSON.toLowerCase()); types.add(SupportedFormat.N3.toLowerCase()); types.add(SupportedFormat.N_TRIPLE.toLowerCase()); types.add(SupportedFormat.RDF_JSON.toLowerCase()); types.add(SupportedFormat.RDF_XML.toLowerCase()); types.add(SupportedFormat.TURTLE.toLowerCase()); types.add(SupportedFormat.X_TURTLE.toLowerCase()); supportedMediaTypes = Collections.unmodifiableSet(types); } @Reference private Parser parser; @Override public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { String mediaTypeWithoutParameter = mediaType.getType().toLowerCase()+'/'+ mediaType.getSubtype().toLowerCase(); log.debug(\"isreadable: [genericType: {}| mediaType {}]\", genericType,mediaTypeWithoutParameter); //second the media type boolean mediaTypeOK = (//the MimeTypes of Representations supportedMediaTypes.contains(mediaTypeWithoutParameter) || //as well as URL encoded MediaType.APPLICATION_FORM_URLENCODED.equals(mediaTypeWithoutParameter) || //and mime multipart MediaType.MULTIPART_FORM_DATA.equals(mediaTypeWith"}
{"text": "setLayout(new BorderLayout(0, 0)); setBorder(new EmptyBorder(4, 4, 3, 4)); JPanel topPanel = new JPanel(new BorderLayout()); JPanel plotterPanel = new JPanel(new VariableGridLayout(0, 1, 4, 4, true, true)); add(topPanel, BorderLayout.NORTH); add(plotterPanel, BorderLayout.CENTER); JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 5)); topPanel.add(controlPanel, BorderLayout.CENTER); threadMeter = new PlotterPanel(Messages.NUMBER_OF_THREADS, Plotter.Unit.NONE, true); threadMeter.plotter.createSequence(threadCountKey, Messages.LIVE_THREADS, threadCountColor, true); threadMeter.plotter.createSequence(peakKey, Messages.PEAK, peakColor, true); setAccessibleName(threadMeter.plotter, Messages.THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME); plotterPanel.add(threadMeter); timeComboBox = new TimeComboBox(threadMeter.plotter); controlPanel.add(new LabeledComponent(Messages.TIME_RANGE_COLON, Resources.getMnemonicInt(Messages.TIME_RANGE_COLON), timeComboBox)); listModel = new DefaultListModel<Long>(); JTextArea textArea = new JTextArea(); textArea.setBorder(thinEmptyBorder); textArea.setEditable(false); setAccessibleName(textArea, Messages.THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME); ThreadJList list = new ThreadJList(listModel, textArea); Dimension di = new Dimension(super.getPreferredSize()); di.width = Math.min(di.width, 200); JScrollPane threadlistSP = new JScrollPane(list); threadlistSP.setPreferredSize(di); threadlistSP.setBorder(null); JScrollPane textAreaSP = new JScrollPane(textArea); textAreaSP.setBorder(null); threadListTabbedPane = new JTabbedPane"}
{"text": "outParameter)); boolean typeOk = JerseyUtils.testParameterizedType(Map.class, new Class[]{String.class,Representation.class}, genericType); log.debug(\"type is {} for {} against Map<String,Representation>\", typeOk ? \"compatible\" : \"incompatible\" ,genericType); return typeOk && mediaTypeOK; } @Override public Map<String,Representation> readFrom(Class<Map<String,Representation>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String,String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException { log.info(\"Read Representations from Request Data\"); long start = System.currentTimeMillis(); //(1) get the charset and the acceptedMediaType String charset = \"UTF-8\"; if(mediaType.getParameters().containsKey(\"charset\")){ charset = mediaType.getParameters().get(\"charset\"); } MediaType acceptedMediaType = getAcceptedMediaType(httpHeaders); log.info(\"readFrom: mediaType {} | accepted {} | charset {}\", new Object[]{mediaType,acceptedMediaType,charset}); // (2) read the Content from the request (this needs to deal with // MediaType.APPLICATION_FORM_URLENCODED_TYPE and // MediaType.MULTIPART_FORM_DATA_TYPE requests! RequestData content; if(mediaType.isCompatible(MediaType.APPLICATION_FORM_URLENCODED_TYPE)) { try { content = MessageBodyReaderUtils.formForm(entityStream, charset, \"encoding\",Arrays.asList(\"entity\",\"content\")); } catch (IllegalArgumentException e) { log.info(\"Bad Request: {}\",e); throw new WebApplicationException( Response.status(Status.BAD_REQUEST).entity(e.toString()). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } if(content.getMediaType() == null){ String message = String.format( \"Missing parameter %s used to specify the media type\" + \"(supported values: %s\", \"encoding\",supportedMediaTypes); log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD_REQUEST).entity(message). header(HttpHeaders.ACCEPT, accepted"}
{"text": "(JTabbedPane.TOP); threadsSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, threadlistSP, textAreaSP); threadsSplitPane.setOneTouchExpandable(true); threadsSplitPane.setBorder(null); JPanel firstTabPanel = new JPanel(new BorderLayout()); firstTabPanel.setOpaque(false); JPanel firstTabToolPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 2)); firstTabToolPanel.setOpaque(false); filterTF = new PromptingTextField(\"Filter\", 20); filterTF.getDocument().addDocumentListener(this); firstTabToolPanel.add(filterTF); JSeparator separator = new JSeparator(JSeparator.VERTICAL); separator.setPreferredSize(new Dimension(separator.getPreferredSize().width, filterTF.getPreferredSize().height)); firstTabToolPanel.add(separator); JButton detectDeadlockButton = new JButton(Messages.DETECT_DEADLOCK); detectDeadlockButton.setMnemonic(Resources.getMnemonicInt(Messages.DETECT_DEADLOCK)); detectDeadlockButton.setActionCommand(\"detectDeadlock\"); detectDeadlockButton.addActionListener(this); detectDeadlockButton.setToolTipText(Messages.DETECT_DEADLOCK_TOOLTIP); firstTabToolPanel.add(detectDeadlockButton); messageLabel = new JLabel(); firstTabToolPanel.add(messageLabel); firstTabPanel.add(threadsSplitPane, BorderLayout.CENTER); firstTabPanel.add(firstTabToolPanel, BorderLayout.SOUTH); threadListTabbedPane.addTab(Messages.THREADS, firstTabPanel); plotterPanel.add(threadListTabbedPane); } private long oldThreads[] = new long[0]; public SwingWorker<?, ?> newSwingWorker() { final ProxyClient proxyClient = vmPanel.getProxyClient(); if (!plotterListening) { proxyClient.addWeakPropertyChangeListener(threadMeter.plotter); plotterListening = true; } return new SwingWorker<Boolean, Object>() { private int t"}
{"text": "MediaType).build()); } if(!isSupported(content.getMediaType())){ String message = String.format( \"Unsupported Content-Type specified by parameter \" + \"encoding=%s (supported: %s)\", content.getMediaType().toString(),supportedMediaTypes); log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD_REQUEST). entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } } else if(mediaType.isCompatible(MediaType.MULTIPART_FORM_DATA_TYPE)){ log.info(\"read from MimeMultipart\"); List<RequestData> contents; try { contents = MessageBodyReaderUtils.fromMultipart(entityStream, mediaType); } catch (IllegalArgumentException e) { log.info(\"Bad Request: {}\",e.toString()); throw new WebApplicationException( Response.status(Status.BAD_REQUEST).entity(e.toString()). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } if(contents.isEmpty()){ String message = \"Request does not contain any Mime BodyParts.\"; log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD_REQUEST).entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } else if(contents.size()>1){ //print warnings about ignored parts log.warn(\"{} Request contains more than one Parts: others than \" + \"the first will be ignored\", MediaType.MULTIPART_FORM_DATA_TYPE); for(int i=1;i<contents.size();i++){ RequestData ignored = contents.get(i); log.warn(\" ignore Content {}: Name {}| MediaType {}\", new Object[] {i+1,ignored.getName(),ignored.getMediaType()}); } } content = contents.get(0); if(content.getMediaType() == null){ String message = String.format( \"MediaType not specified for mime body part for file %s. \" + \"The media type must be one of the supported values: %s\", content.getName(), supportedMediaTypes); log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD"}
{"text": "lCount; private int tpCount; private long ttCount; private long[] threads; private long timeStamp; public Boolean doInBackground() { try { ThreadMXBean threadMBean = proxyClient.getThreadMXBean(); tlCount = threadMBean.getThreadCount(); tpCount = threadMBean.getPeakThreadCount(); if (overviewPanel != null) { ttCount = threadMBean.getTotalStartedThreadCount(); } else { ttCount = 0L; } threads = threadMBean.getAllThreadIds(); for (long newThread : threads) { if (nameCache.get(newThread) == null) { ThreadInfo ti = threadMBean.getThreadInfo(newThread); if (ti != null) { String name = ti.getThreadName(); if (name != null) { nameCache.put(newThread, name); } } } } timeStamp = System.currentTimeMillis(); return true; } catch (IOException e) { return false; } catch (UndeclaredThrowableException e) { return false; } } protected void done() { try { if (!get()) { return; } } catch (InterruptedException ex) { return; } catch (ExecutionException ex) { if (JConsole.isDebug()) { ex.printStackTrace(); } return; } threadMeter.plotter.addValues(timeStamp, tlCount, tpCount); threadMeter.setValueLabel(tlCount+\"\"); if (overviewPanel != null) { overviewPanel.updateThreadsInfo(tlCount, tpCount, ttCount, timeStamp); } String filter = filterTF.getText().toLowerCase(Locale.ENGLISH); boolean doFilter = (filter.length() > 0); ArrayList<Long> l = new ArrayList<Long>(); for (long t : threads) { l.add(t); } Iterator<Long> iterator = l.iterator(); while (iterator.hasNext()) { long newThread = iterator.next(); String name = nameCache.get(newThread); if (doFilter && name != null && name.toLowerCase(Locale.ENGLISH).indexOf(filter) < 0) { iterator.remove(); } } long[] newThreads = threads; if (l.size() < threads."}
{"text": "_REQUEST).entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } if(!isSupported(content.getMediaType())){ String message = String.format( \"Unsupported Content-Type %s specified for mime body part \" + \"for file %s (supported: %s)\", content.getMediaType(),content.getName(),supportedMediaTypes); log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD_REQUEST). entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } } else { content = new RequestData(mediaType, null, entityStream); } long readingCompleted = System.currentTimeMillis(); log.info(\" ... reading request data {}ms\",readingCompleted-start); Map<String,Representation> parsed = parseFromContent(content,acceptedMediaType); long parsingCompleted = System.currentTimeMillis(); log.info(\" ... parsing data {}ms\",parsingCompleted-readingCompleted); return parsed; } public Map<String,Representation> parseFromContent(RequestData content, MediaType acceptedMediaType){ // (3) Parse the Representtion(s) form the entity stream if(content.getMediaType().isCompatible(MediaType.APPLICATION_JSON_TYPE)){ //parse from json throw new UnsupportedOperationException(\"Parsing of JSON not yet implemented :(\"); } else if(isSupported(content.getMediaType())){ //from RDF serialisation RdfValueFactory valueFactory = RdfValueFactory.getInstance(); Map<String,Representation> representations = new HashMap<String,Representation>(); Set<BlankNodeOrIRI> processed = new HashSet<BlankNodeOrIRI>(); Graph graph = new IndexedGraph(); try { parser.parse(graph,content.getEntityStream(), content.getMediaType().toString()); } catch (UnsupportedParsingFormatException e) { //String acceptedMediaType = httpHeaders.getFirst(\"Accept\"); //throw an internal server Error, because we check in //isReadable(..) for supported types and still we get here a //unsupported format -> therefore it looks like an configuration //error the server (e.g. a missing Bundle with the required bundle) String message = \"Unable to create the Parser"}
{"text": "length) { newThreads = new long[l.size()]; for (int i = 0; i < newThreads.length; i++) { newThreads[i] = l.get(i); } } for (long oldThread : oldThreads) { boolean found = false; for (long newThread : newThreads) { if (newThread == oldThread) { found = true; break; } } if (!found) { listModel.removeElement(oldThread); if (!doFilter) { nameCache.remove(oldThread); } } } // Threads are in reverse chronological order for (int i = newThreads.length - 1; i >= 0; i--) { long newThread = newThreads[i]; boolean found = false; for (long oldThread : oldThreads) { if (newThread == oldThread) { found = true; break; } } if (!found) { listModel.addElement(newThread); } } oldThreads = newThreads; } }; } long lastSelected = -1; public void valueChanged(ListSelectionEvent ev) { ThreadJList list = (ThreadJList)ev.getSource(); final JTextArea textArea = list.textArea; Long selected = list.getSelectedValue(); if (selected == null) { if (lastSelected != -1) { selected = lastSelected; } } else { lastSelected = selected; } textArea.setText(\"\"); if (selected != null) { final long threadID = selected; workerAdd(new Runnable() { public void run() { ProxyClient proxyClient = vmPanel.getProxyClient(); StringBuilder sb = new StringBuilder(); try { ThreadMXBean threadMBean = proxyClient.getThreadMXBean(); ThreadInfo ti = null; MonitorInfo[] monitors = null; if (proxyClient.isLockUsageSupported() && threadMBean.isObjectMonitorUsageSupported()) { // VMs that support the monitor usage monitoring ThreadInfo[] infos = threadMBean.dumpAllThreads(true, false); for (ThreadInfo info : infos) { if (info.getThreadId() == threadID) { ti = info; monitors = info.getLockedMonitors(); break; } } } else { // VM doesn't support monitor usage monitoring ti = threadMBean.getThreadInfo"}
{"text": "for the supported format\" +content.getMediaType()+\" (\"+e+\")\"; log.error(message,e); throw new WebApplicationException( Response.status(Status.INTERNAL_SERVER_ERROR). entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } catch (RuntimeException e){ //NOTE: Clerezza seams not to provide specific exceptions on // parsing errors. Hence the catch for all RuntimeException String message = \"Unable to parse the provided RDF data (format: \" +content.getMediaType()+\", message: \"+e.getMessage()+\")\"; log.error(message,e); throw new WebApplicationException( Response.status(Status.BAD_REQUEST). entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } for(Iterator<Triple> st = graph.iterator();st.hasNext();){ BlankNodeOrIRI resource = st.next().getSubject(); if(resource instanceof IRI && processed.add(resource)){ //build a new representation representations.put(((IRI)resource).getUnicodeString(), valueFactory.createRdfRepresentation((IRI)resource, graph)); } } return representations; } else { //unsupported media type String message = String.format( \"Parsed Content-Type '%s' is not one of the supported %s\", content.getMediaType(),supportedMediaTypes); log.info(\"Bad Request: {}\",message); throw new WebApplicationException( Response.status(Status.BAD_REQUEST). entity(message). header(HttpHeaders.ACCEPT, acceptedMediaType).build()); } } /** * Internally used to get the accepted media type used when returning * {@link WebApplicationException}s. * @param httpHeaders * @param acceptedMediaType * @return */ private static MediaType getAcceptedMediaType(MultivaluedMap<String,String> httpHeaders) { MediaType acceptedMediaType; String acceptedMediaTypeString = httpHeaders.getFirst(\"Accept\"); if(acceptedMediaTypeString != null){ try { acceptedMediaType = MediaType.valueOf(acceptedMediaTypeString); if(acceptedMediaType.isWildcardType()){ acceptedMediaType = DEFAULT_ACCEPTED_MEDIA_TYPE; } } catch (IllegalArgumentException e) { accepted"}
{"text": "(threadID, Integer.MAX_VALUE); } if (ti != null) { if (ti.getLockName() == null) { sb.append(Resources.format(Messages.NAME_STATE, ti.getThreadName(), ti.getThreadState().toString())); } else if (ti.getLockOwnerName() == null) { sb.append(Resources.format(Messages.NAME_STATE_LOCK_NAME, ti.getThreadName(), ti.getThreadState().toString(), ti.getLockName())); } else { sb.append(Resources.format(Messages.NAME_STATE_LOCK_NAME_LOCK_OWNER, ti.getThreadName(), ti.getThreadState().toString(), ti.getLockName(), ti.getLockOwnerName())); } sb.append(Resources.format(Messages.BLOCKED_COUNT_WAITED_COUNT, ti.getBlockedCount(), ti.getWaitedCount())); sb.append(Messages.STACK_TRACE); int index = 0; for (StackTraceElement e : ti.getStackTrace()) { sb.append(e).append('\\n'); if (monitors != null) { for (MonitorInfo mi : monitors) { if (mi.getLockedStackDepth() == index) { sb.append(Resources.format(Messages.MONITOR_LOCKED, mi.toString())); } } } index++; } } } catch (IOException ex) { // Ignore } catch (UndeclaredThrowableException e) { proxyClient.markAsDead(); } final String text = sb.toString(); SwingUtilities.invokeLater(new Runnable() { public void run() { textArea.setText(text); textArea.setCaretPosition(0); } }); } }); } } private void doUpdate() { workerAdd(new Runnable() { public void run() { update(); } }); } private void detectDeadlock() { workerAdd(new Runnable() { public void run() { try { final Long[][] deadlockedThreads = getDeadlockedThreadIds(); if (deadlockedThreads == null || deadlockedThreads.length == 0) { // Display message for 30 seconds. Do it on a separate thread so // the sleep won't hold up the worker queue. // This will be replaced later by separate statusbar logic. new Thread()"}
{"text": "MediaType = DEFAULT_ACCEPTED_MEDIA_TYPE; } } else { acceptedMediaType = DEFAULT_ACCEPTED_MEDIA_TYPE; } return acceptedMediaType; } /** * Converts the type and the subtype of the parsed media type to the * string representation as stored in {@link #supportedMediaTypes} and than * checks if the parsed media type is contained in this list. * @param mediaType the MediaType instance to check * @return <code>true</code> if the parsed media type is not * <code>null</code> and supported. */ private boolean isSupported(MediaType mediaType){ return mediaType == null ? false : supportedMediaTypes.contains( mediaType.getType().toLowerCase()+'/'+ mediaType.getSubtype().toLowerCase()); } }<s><start> /// /// Massively by HTML5 UP /// html5up.net | @ajlkn /// Free for personal and commercial use under the CCA 3.0 license (html5up.net/license) /// /* Wrapper */ #wrapper { @include vendor('transition', 'opacity #{_duration(menu)} ease'); position: relative; z-index: 1; overflow: hidden; > .bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: _palette(wrapper-bg); background-image: url('../../images/overlay.png'), linear-gradient(0deg, rgba(0,0,0,0.1), rgba(0,0,0,0.1)), url('../../images/bg.jpg'); background-size: auto, auto, 100% auto; background-position: center, center, top center; background-repeat: repeat, no-repeat, no-repeat; background-attachment: scroll, scroll, scroll; z-index: -1; &.fixed { position: fixed; width: 100vw; height: 100vh; } } &.fade-in { &:before { @include vendor('pointer-events', 'none'); @include vendor('transition', 'opacity 1s ease-in-out'); @include vendor('transition-delay', '0.75s'); background: _palette(invert"}
{"text": "{ public void run() { try { SwingUtilities.invokeAndWait(new Runnable() { public void run() { String msg = Messages.NO_DEADLOCK_DETECTED; messageLabel.setText(msg); threadListTabbedPane.revalidate(); } }); sleep(30 * 1000); } catch (InterruptedException ex) { // Ignore } catch (InvocationTargetException ex) { // Ignore } SwingUtilities.invokeLater(new Runnable() { public void run() { messageLabel.setText(\"\"); } }); } }.start(); return; } SwingUtilities.invokeLater(new Runnable() { public void run() { // Remove old deadlock tabs while (threadListTabbedPane.getTabCount() > 1) { threadListTabbedPane.removeTabAt(1); } if (deadlockedThreads != null) { for (int i = 0; i < deadlockedThreads.length; i++) { DefaultListModel<Long> listModel = new DefaultListModel<Long>(); JTextArea textArea = new JTextArea(); textArea.setBorder(thinEmptyBorder); textArea.setEditable(false); setAccessibleName(textArea, Messages.THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME); ThreadJList list = new ThreadJList(listModel, textArea); JScrollPane threadlistSP = new JScrollPane(list); JScrollPane textAreaSP = new JScrollPane(textArea); threadlistSP.setBorder(null); textAreaSP.setBorder(null); JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, threadlistSP, textAreaSP); splitPane.setOneTouchExpandable(true); splitPane.setBorder(null); splitPane.setDividerLocation(threadsSplitPane.getDividerLocation()); String tabName; if (deadlockedThreads.length > 1) { tabName = Resources.format(Messages.DEADLOCK_TAB_N, i+1); } else { tabName = Messages.DEADLOCK_TAB; } threadListTabbedPane.addTab(tabName, splitPane); for (long t : deadlockedThreads[i])"}
{"text": ", bg); content: ''; display: block; height: 100%; left: 0; opacity: 0; position: fixed; top: 0; width: 100%; } body.is-loading & { &:before { opacity: 1; } } } @include orientation(portrait) { > .bg { background-size: auto, auto, auto 175%; } } }<s><start> # frozen_string_literal: true require File.expand_path('lib/jekyll-last-modified-at/version.rb', __dir__) Gem::Specification.new do |s| s.name = 'jekyll-last-modified-at' s.version = Jekyll::LastModifiedAt::VERSION s.summary = 'A liquid tag for Jekyll to indicate the last time a file was modified.' s.authors = 'Garen J. Torikian' s.homepage = 'https://github.com/gjtorikian/jekyll-last-modified-at' s.license = 'MIT' s.files = Dir['lib/**/*.rb'] s.add_dependency 'jekyll', '>= 3.7', ' < 5.0' s.add_dependency 'posix-spawn', '~> 0.3.9' s.add_development_dependency 'rake' s.add_development_dependency 'rspec', '~> 3.4' s.add_development_dependency 'rubocop' s.add_development_dependency 'rubocop-performance' s.add_development_dependency 'rubocop-standard' s.add_development_dependency 'spork' end<s><start> #if !defined(BOOST_PP_IS_ITERATING) ///// header body #ifndef BOOST_MPL_AUX778076_ADVANCE_BACKWARD_HPP_INCLUDED #define BOOST_MPL_AUX778076_ADVANCE_BACKWARD_HPP_INCLUDED // Copyright Aleksey Gurtovoy 2000-2004 // // Distributed under the Boost Software License"}
{"text": "{ listModel.addElement(t); } } threadListTabbedPane.setSelectedIndex(1); } } }); } catch (IOException e) { // Ignore } catch (UndeclaredThrowableException e) { vmPanel.getProxyClient().markAsDead(); } } }); } // Return deadlocked threads or null public Long[][] getDeadlockedThreadIds() throws IOException { ProxyClient proxyClient = vmPanel.getProxyClient(); ThreadMXBean threadMBean = proxyClient.getThreadMXBean(); long[] ids = proxyClient.findDeadlockedThreads(); if (ids == null) { return null; } ThreadInfo[] infos = threadMBean.getThreadInfo(ids, Integer.MAX_VALUE); List<Long[]> dcycles = new ArrayList<Long[]>(); List<Long> cycle = new ArrayList<Long>(); // keep track of which thread is visited // one thread can only be in one cycle boolean[] visited = new boolean[ids.length]; int deadlockedThread = -1; // Index into arrays while (true) { if (deadlockedThread < 0) { if (cycle.size() > 0) { // a cycle found dcycles.add(cycle.toArray(new Long[0])); cycle = new ArrayList<Long>(); } // start a new cycle from a non-visited thread for (int j = 0; j < ids.length; j++) { if (!visited[j]) { deadlockedThread = j; visited[j] = true; break; } } if (deadlockedThread < 0) { // done break; } } cycle.add(ids[deadlockedThread]); long nextThreadId = infos[deadlockedThread].getLockOwnerId(); for (int j = 0; j < ids.length; j++) { ThreadInfo ti = infos[j]; if (ti.getThreadId() == nextThreadId) { if (visited[j]) { deadlockedThread = -1; } else { deadlockedThread = j; visited[j] = true; } break; } } } return dcycles.toArray(new Long[0][0]); } // ActionListener interface public void actionPerformed(ActionEvent evt) { String cmd = ((AbstractButton)evt.getSource()).getActionCommand(); if"}
{"text": ", Version 1.0. // (See accompanying file LICENSE_1_0.txt or copy at // http://www.boost.org/LICENSE_1_0.txt) // // See http://www.boost.org/libs/mpl for documentation. // $Id$ // $Date$ // $Revision$ #if !defined(BOOST_MPL_PREPROCESSING_MODE) # include <boost/mpl/prior.hpp> # include <boost/mpl/apply_wrap.hpp> #endif #include <boost/mpl/aux_/config/use_preprocessed.hpp> #if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \\ && !defined(BOOST_MPL_PREPROCESSING_MODE) # define BOOST_MPL_PREPROCESSED_HEADER advance_backward.hpp # include <boost/mpl/aux_/include_preprocessed.hpp> #else # include <boost/mpl/limits/unrolling.hpp> # include <boost/mpl/aux_/nttp_decl.hpp> # include <boost/mpl/aux_/config/eti.hpp> # include <boost/preprocessor/iterate.hpp> # include <boost/preprocessor/cat.hpp> # include <boost/preprocessor/inc.hpp> namespace boost { namespace mpl { namespace aux { // forward declaration template< BOOST_MPL_AUX_NTTP_DECL(long, N) > struct advance_backward; # define BOOST_PP_ITERATION_PARAMS_1 \\ (3,(0, BOOST_MPL_LIMIT_UNROLLING, <boost/mpl/aux_/advance_backward.hpp>)) # include BOOST_PP_ITERATE() // implementation for N that exceeds BOOST_MPL_LIMIT_UNROLLING template< BOOST_MPL_AUX_NTTP_DECL(long, N) > struct advance_backward { template< typename Iterator > struct apply { typedef typename apply_wrap1< advance_backward<BOOST_MPL_LIMIT_UNROLLING> , Iterator"}
{"text": "(cmd == \"detectDeadlock\") { messageLabel.setText(\"\"); detectDeadlock(); } } // DocumentListener interface public void insertUpdate(DocumentEvent e) { doUpdate(); } public void removeUpdate(DocumentEvent e) { doUpdate(); } public void changedUpdate(DocumentEvent e) { doUpdate(); } private class ThreadJList extends JList<Long> { private JTextArea textArea; ThreadJList(DefaultListModel<Long> listModel, JTextArea textArea) { super(listModel); this.textArea = textArea; setBorder(thinEmptyBorder); setSelectionMode(ListSelectionModel.SINGLE_SELECTION); textArea.setText(Messages.THREAD_TAB_INITIAL_STACK_TRACE_MESSAGE); addListSelectionListener(ThreadTab.this); setCellRenderer(new DefaultListCellRenderer() { public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) { super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus); if (value != null) { String name = nameCache.get(value); if (name == null) { name = value.toString(); } setText(name); } return this; } }); } public Dimension getPreferredSize() { Dimension d = super.getPreferredSize(); d.width = Math.max(d.width, 100); return d; } } private class PromptingTextField extends JTextField implements FocusListener { private String prompt; boolean promptRemoved = false; Color fg; public PromptingTextField(String prompt, int columns) { super(prompt, columns); this.prompt = prompt; updateForeground(); addFocusListener(this); setAccessibleName(this, prompt); } @Override public void revalidate() { super.revalidate(); updateForeground(); } private void updateForeground() { this.fg = UIManager.getColor(\"TextField.foreground\"); if (promptRemoved) { setForeground(fg); } else { setForeground(Color.gray); } } public String getText() { if (!promptRemoved) { return \"\"; } else { return super.getText(); } } public void focusGained(FocusEvent e) { if (!prompt"}
{"text": ">::type chunk_result_; typedef typename apply_wrap1< advance_backward<( (N - BOOST_MPL_LIMIT_UNROLLING) < 0 ? 0 : N - BOOST_MPL_LIMIT_UNROLLING )> , chunk_result_ >::type type; }; }; }}} #endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS #endif // BOOST_MPL_AUX778076_ADVANCE_BACKWARD_HPP_INCLUDED ///// iteration, depth == 1 // For gcc 4.4 compatability, we must include the // BOOST_PP_ITERATION_DEPTH test inside an #else clause. #else // BOOST_PP_IS_ITERATING #if BOOST_PP_ITERATION_DEPTH() == 1 #define i_ BOOST_PP_FRAME_ITERATION(1) template<> struct advance_backward< BOOST_PP_FRAME_ITERATION(1) > { template< typename Iterator > struct apply { typedef Iterator iter0; #if i_ > 0 # define BOOST_PP_ITERATION_PARAMS_2 \\ (3,(1, BOOST_PP_FRAME_ITERATION(1), <boost/mpl/aux_/advance_backward.hpp>)) # include BOOST_PP_ITERATE() #endif typedef BOOST_PP_CAT(iter,BOOST_PP_FRAME_ITERATION(1)) type; }; #if defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG) /// ETI workaround template<> struct apply<int> { typedef int type; }; #endif }; #undef i_ ///// iteration, depth == 2 #elif BOOST_PP_ITERATION_DEPTH() == 2 # define AUX778076_ITER_0 BOOST_PP_CAT(iter,BOOST_PP_DEC(BOOST_PP_FRAME_ITERATION(2))) # define AUX778076_ITER_1 BOOST_"}
{"text": "Removed) { setText(\"\"); setForeground(fg); promptRemoved = true; } } public void focusLost(FocusEvent e) { if (promptRemoved && getText().isEmpty()) { setText(prompt); setForeground(Color.gray); promptRemoved = false; } } } OverviewPanel[] getOverviewPanels() { if (overviewPanel == null) { overviewPanel = new ThreadOverviewPanel(); } return new OverviewPanel[] { overviewPanel }; } private static class ThreadOverviewPanel extends OverviewPanel { ThreadOverviewPanel() { super(Messages.THREADS, threadCountKey, Messages.LIVE_THREADS, null); } private void updateThreadsInfo(long tlCount, long tpCount, long ttCount, long timeStamp) { getPlotter().addValues(timeStamp, tlCount); getInfoLabel().setText(Resources.format(Messages.THREAD_TAB_INFO_LABEL_FORMAT, tlCount, tpCount, ttCount)); } } }<s><start> [weewx] name=weewx baseurl=http://weewx.com/yum/weewx/el7 enabled=1 gpgcheck=0<s><start> // // GDDropboxUploadStateWrapper.m // GDFileManagerExample // // Created by Graham Dennis on 11/08/13. // Copyright (c) 2013 Graham Dennis. All rights reserved. // #import \"GDFileManagerUploadState.h\" @implementation GDFileManagerUploadState @synthesize parentVersionID = _parentVersionID; - (instancetype)initWithUploadState:(id<NSCoding>)uploadState mimeType:(NSString *)mimeType uploadURL:(NSURL *)uploadURL parentVersionID:(NSString *)parentVersionID { return [self initWithUploadState:uploadState mimeType:mimeType uploadURL:uploadURL parentVersionID:parentVersionID extraState:nil]; } - (instancetype)initWithUploadState:(id <NSCoding>)uploadState mimeType:(NSString *)mimeType uploadURL:(NSURL *)uploadURL parentVersionID:(NSString *)parentVersionID extraState:(NSDictionary *)extraState { if ((self = [super init])) { _"}
{"text": "PP_CAT(iter,BOOST_PP_FRAME_ITERATION(2)) typedef typename prior<AUX778076_ITER_0>::type AUX778076_ITER_1; # undef AUX778076_ITER_1 # undef AUX778076_ITER_0 #endif // BOOST_PP_ITERATION_DEPTH() #endif // BOOST_PP_IS_ITERATING<s><start> <UIView; frame = (0 0; 1112 834); autoresize = W+H; layer = <CALayer>> | <UILabel; frame = (528.333 20; 55.6667 20.3333); text = 'What's'; userInteractionEnabled = NO; layer = <_UILabelLayer>> | <UILabel; frame = (0 417; 25 20.3333); text = 'the'; userInteractionEnabled = NO; layer = <_UILabelLayer>> | <UILabel; frame = (1073 417; 39 20.3333); text = 'point'; userInteractionEnabled = NO; layer = <_UILabelLayer>> | <UILabel; frame = (552.333 816; 7.66667 18); text = '?'; userInteractionEnabled = NO; layer = <_UILabelLayer>><s><start> package x509util import ( \"crypto/rand\" \"crypto/rsa\" \"crypto/x509\" \"crypto/x509/pkix\" \"testing\" ) func TestCreateCertificateRequest(t *testing.T) { r := rand.Reader priv, err := rsa.GenerateKey(r, 1024) if err != nil { t.Fatal(err) } template := CertificateRequest{ CertificateRequest: x509.CertificateRequest{ Subject: pkix.Name{ CommonName: \"test.acme.co\", Country: []string{\"US\"}, }, }, ChallengePassword:"}
{"text": "uploadState = uploadState; _uploadURL = uploadURL; _parentVersionID = parentVersionID; _mimeType = mimeType; _extraState = extraState; } return self; } - (NSURL *)fileServiceSessionURL { return self.uploadURL; } #pragma mark - NSCoding static NSString *const kUploadState = @\"UploadState\"; static NSString *const kUploadURL = @\"UploadURL\"; static NSString *const kParentVersionID = @\"ParentVersionID\"; static NSString *const kMIMEType = @\"MIMEType\"; static NSString *const kExtraState = @\"ExtraState\"; - (id)initWithCoder:(NSCoder *)aDecoder { id <NSCoding> uploadState = [aDecoder decodeObjectForKey:kUploadState]; NSURL *uploadURL = [aDecoder decodeObjectForKey:kUploadURL]; NSString *parentVersionID = [aDecoder decodeObjectForKey:kParentVersionID]; NSString *mimeType = [aDecoder decodeObjectForKey:kMIMEType]; NSDictionary *extraState = [aDecoder decodeObjectForKey:kExtraState]; return [self initWithUploadState:uploadState mimeType:mimeType uploadURL:uploadURL parentVersionID:parentVersionID extraState:extraState]; } - (void)encodeWithCoder:(NSCoder *)aCoder { [aCoder encodeObject:self.uploadState forKey:kUploadState]; [aCoder encodeObject:self.uploadURL forKey:kUploadURL]; [aCoder encodeObject:self.parentVersionID forKey:kParentVersionID]; [aCoder encodeObject:self.mimeType forKey:kMIMEType]; [aCoder encodeObject:self.extraState forKey:kExtraState]; } @end<s><start> File.open(${1:path_to_yml}, \"w\") { |${2:file}| YAML.dump(${3:obj}, ${4:$2}) }<s><start> # matchPath Re-exported from core [`matchPath`](../../../react-router/docs/api/matchPath.md)<s><start> $ brew update $ brew install opam<s><start> /dts-v1/; #include \"bcm6348.dtsi\" #include <dt-bindings/input/input.h> /"}
{"text": "\"foobar\", } derBytes, err := CreateCertificateRequest(r, &template, priv) if err != nil { t.Fatal(err) } out, err := x509.ParseCertificateRequest(derBytes) if err != nil { t.Fatalf(\"failed to create certificate request: %s\", err) } if err := out.CheckSignature(); err != nil { t.Errorf(\"failed to check certificate request signature: %s\", err) } challenge, err := ParseChallengePassword(derBytes) if err != nil { t.Fatalf(\"failed to parse challengePassword attribute: %s\", err) } if have, want := challenge, template.ChallengePassword; have != want { t.Errorf(\"have %s, want %s\", have, want) } }<s><start> // Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. package com.intellij.openapi.vcs.impl import com.intellij.ProjectTopics import com.intellij.openapi.application.ApplicationManager import com.intellij.openapi.components.service import com.intellij.openapi.extensions.ExtensionNotApplicableException import com.intellij.openapi.module.Module import com.intellij.openapi.module.ModuleManager import com.intellij.openapi.project.ModuleListener import com.intellij.openapi.project.Project import com.intellij.openapi.project.rootManager import com.intellij.openapi.roots.ModuleRootEvent import com.intellij.openapi.roots.ModuleRootListener import com.intellij.openapi.startup.StartupActivity import com.intellij.openapi.vcs.AbstractVcs import com.intellij.openapi.vcs.ProjectLevelVcsManager import com.intellij.openapi.vcs.VcsDirectoryMapping import com.intellij.openapi.vfs.VirtualFile internal class ModuleVcsDetector(private val project: Project) { private val vcsManager by lazy(LazyThreadSafetyMode.NONE) { (ProjectLevelVcsManager.getInstance(project) as ProjectLevelVcsManagerImpl) } internal class MyPostStartUpActivity : Startup"}
{"text": "{ model = \"Sagem F@st 2404\"; compatible = \"sagem,fast-2404\", \"brcm,bcm6348\"; chosen { bootargs = \"rootfstype=squashfs,jffs2 noinitrd console=ttyS0,115200\"; stdout-path = \"serial0:115200n8\"; }; }; &pflash { status = \"okay\"; partitions { compatible = \"fixed-partitions\"; #address-cells = <1>; #size-cells = <1>; cfe@0 { label = \"CFE\"; reg = <0x000000 0x010000>; read-only; }; linux@10000 { label = \"linux\"; reg = <0x010000 0x3e0000>; compatible = \"brcm,bcm963xx-imagetag\"; }; nvram@3f0000 { label = \"nvram\"; reg = <0x3f0000 0x010000>; }; }; }; &pinctrl { pinctrl-names = \"default\"; pinctrl-0 = <&pinctrl_pci &pinctrl_ext_mii &pinctrl_mii_pccard>; }; &uart0 { status = \"okay\"; };<s><start> ; ; Definition file of CRYPTCATSVC.dll ; Automatic generated by gendef ; written by Kai Tietz 2008-2014 ; LIBRARY \"CRYPTCATSVC.dll\" EXPORTS CryptsvcDllCtrl<s><start> // // TAPIResponse.m // TwitterNetworkLayer // // Created on 10/17/14. // Copyright \u00a9 2020 Twitter. All rights reserved. // #import \"TAPIError.h\" #import \"TAPIResponse.h\" #import \"TNL_Project.h\" NS_INLINE BOOL _DataBeginsWithHTMLDocType(NSData *data) { static const char sDocType[] = \"<!DOCTYPE html\"; static const size_t sDocTypeLength = (sizeof(sDocType"}
{"text": "Activity.DumbAware { init { if (ApplicationManager.getApplication().isUnitTestMode) { throw ExtensionNotApplicableException.INSTANCE } } override fun runActivity(project: Project) { val vcsDetector = project.service<ModuleVcsDetector>() val listener = vcsDetector.MyModulesListener() val busConnection = project.messageBus.connect() busConnection.subscribe(ProjectTopics.MODULES, listener) busConnection.subscribe(ProjectTopics.PROJECT_ROOTS, listener) if (vcsDetector.vcsManager.needAutodetectMappings()) { vcsDetector.autoDetectVcsMappings(true) } } } private inner class MyModulesListener : ModuleRootListener, ModuleListener { private val myMappingsForRemovedModules: MutableList<VcsDirectoryMapping> = mutableListOf() override fun beforeRootsChange(event: ModuleRootEvent) { myMappingsForRemovedModules.clear() } override fun rootsChanged(event: ModuleRootEvent) { myMappingsForRemovedModules.forEach { mapping -> vcsManager.removeDirectoryMapping(mapping) } // the check calculates to true only before user has done any change to mappings, i.e. in case modules are detected/added automatically // on start etc (look inside) if (vcsManager.needAutodetectMappings()) { autoDetectVcsMappings(false) } } override fun moduleAdded(project: Project, module: Module) { myMappingsForRemovedModules.removeAll(getMappings(module)) autoDetectModuleVcsMapping(module) } override fun beforeModuleRemoved(project: Project, module: Module) { myMappingsForRemovedModules.addAll(getMappings(module)) } } private fun autoDetectVcsMappings(tryMapPieces: Boolean) { if (vcsManager.haveDefaultMapping() != null) return val usedVcses = mutableSetOf<AbstractVcs?>() val detectedRoots = mutableSetOf<Pair<VirtualFile, AbstractVcs>>() val roots = ModuleManager.getInstance(project).modules.flatMap { it.rootManager.contentRoots.asIterable() }.distinct() for (root in roots) { val module"}
{"text": ") / sizeof(sDocType[0])) - 1; // minus 1 to ignore the NULL terminator return data.length >= sDocTypeLength && 0 == strncmp(data.bytes, sDocType, sDocTypeLength); } static id _ParseAPIResponse(TNLResponseInfo *info, NSError ** parseErrorOut, NSError ** apiErrorOut); static NSArray *_ExtractAPIErrors(id parsedObject); @implementation TAPIResponse @synthesize apiError = _apiError; @synthesize parseError = _parseError; @synthesize parsedObject = _parsedObject; - (void)prepare { [super prepare]; if (!_operationError) { NSError *apiError; NSError *parseError; _parsedObject = _ParseAPIResponse(_info, &parseError, &apiError); _parseError = parseError; _apiError = apiError; TNLAttemptMetrics *metrics = _metrics.attemptMetrics.lastObject; metrics.responseBodyParseError = parseError; if (apiError) { metrics.APIErrors = @[apiError]; } } } - (instancetype)initWithCoder:(NSCoder *)coder { self = [super initWithCoder:coder]; if (self) { _parsedObject = [coder decodeObjectOfClasses:[NSSet setWithObjects:[NSString class], [NSNumber class], [NSArray class], [NSDictionary class], nil] forKey:@\"parsedObject\"]; _parseError = [coder decodeObjectOfClass:[NSError class] forKey:@\"parseError\"]; _apiError = [coder decodeObjectOfClass:[NSError class] forKey:@\"apiError\"]; } return self; } - (void)encodeWithCoder:(NSCoder *)aCoder { [super encodeWithCoder:aCoder]; [aCoder encodeObject:TNLErrorToSecureCodingError(_parsedObject) forKey:@\"parsedObject\"]; [aCoder encodeObject:TNLErrorToSecureCodingError(_apiError) forKey:@\"apiError\"]; [aCoder encodeObject:TNLErrorToSecureCodingError(_parseError) forKey:@\"parseError\"]; } - (NSError *)anyError { return self.operationError ?: self.parseError"}
{"text": "Vcs = vcsManager.findVersioningVcs(root) if (moduleVcs != null) { detectedRoots.add(Pair(root, moduleVcs)) } usedVcses.add(moduleVcs) // put 'null' for unmapped module } val commonVcs = usedVcses.singleOrNull() if (commonVcs != null) { // Remove existing mappings that will duplicate added <Project> mapping. val rootPaths = roots.map { it.path }.toSet() val additionalMappings = vcsManager.directoryMappings.filter { it.directory !in rootPaths } vcsManager.setAutoDirectoryMappings(additionalMappings + VcsDirectoryMapping.createDefault(commonVcs.name)) } else if (tryMapPieces) { val newMappings = detectedRoots.map { (root, vcs) -> VcsDirectoryMapping(root.path, vcs.name) } vcsManager.setAutoDirectoryMappings(vcsManager.directoryMappings + newMappings) } } private fun autoDetectModuleVcsMapping(module: Module) { if (vcsManager.haveDefaultMapping() != null) return val newMappings = mutableListOf<VcsDirectoryMapping>() for (file in module.rootManager.contentRoots) { val vcs = vcsManager.findVersioningVcs(file) if (vcs != null && vcs !== vcsManager.getVcsFor(file)) { newMappings.add(VcsDirectoryMapping(file.path, vcs.name)) } } if (newMappings.isNotEmpty()) { vcsManager.setAutoDirectoryMappings(vcsManager.directoryMappings + newMappings) } } private fun getMappings(module: Module): List<VcsDirectoryMapping> { return module.rootManager.contentRoots .mapNotNull { root -> vcsManager.directoryMappings.firstOrNull { it.directory == root.path } } } }<s><start> package io.gitlab.arturbosch.detekt.generator.collection import io.gitlab.arturbosch.detekt.api.DetektVisitor import io.gitlab.arturbosch.detekt.generator.collection.exception.InvalidDocumentationException"}
{"text": "?: self.apiError; } @end static id _ParseAPIResponse(TNLResponseInfo *info, NSError ** errorOut, NSError ** apiErrorOut) { id json = nil; NSError *parseError = nil; __block NSError *apiError = TNLHTTPStatusCodeIsSuccess(info.statusCode) ? nil : [NSError errorWithDomain:TAPIErrorDomain code:0 userInfo:nil]; NSInteger statusCode = info.statusCode; NSData *data = info.data; TNLAssert(statusCode > 0); BOOL hasDocTypePrefix = _DataBeginsWithHTMLDocType(data); if (hasDocTypePrefix) { parseError = [NSError errorWithDomain:TAPIOperationErrorDomain code:TAPIOperationErrorCodeServiceEncounteredTechnicalError userInfo:nil]; } else { json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&parseError]; if (json) { NSArray *apiErrors = _ExtractAPIErrors(json); // Underlying behavior in some 4XX errors if (TNLHTTPStatusCodeIsClientError(statusCode)) { [apiErrors enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { NSError *currentError = obj; if ([currentError.domain isEqualToString:TAPIErrorDomain]) { apiError = currentError; *stop = YES; } }]; } } else { parseError = [NSError errorWithDomain:TAPIParseErrorDomain code:TAPIParseErrorCodeCannotParseResponse userInfo:(parseError) ? @{ NSUnderlyingErrorKey : parseError } : nil]; } } if (errorOut) { *errorOut = parseError; } if (apiErrorOut) { *apiErrorOut = apiError; } return json; } static NSArray *_ExtractAPIErrors(id parsedObject) { TNLAssert(parsedObject != nil); NSMutableArray *errorItems = [[NSMutableArray alloc] init]; if ([parsedObject isKindOfClass:[NSDictionary class]]) { id errors = [parsedObject objectForKey:@\"errors\"]; if ([errors isKindOfClass:[NSArray class]]) { [errors enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { BOOL successfullyParsedError = NO;"}
{"text": "import io.gitlab.arturbosch.detekt.rules.isOverride import org.jetbrains.kotlin.psi.KtCallExpression import org.jetbrains.kotlin.psi.KtClassOrObject import org.jetbrains.kotlin.psi.KtFile import org.jetbrains.kotlin.psi.KtProperty import org.jetbrains.kotlin.psi.KtReferenceExpression import org.jetbrains.kotlin.psi.KtSuperTypeList import org.jetbrains.kotlin.psi.KtValueArgumentList import org.jetbrains.kotlin.psi.psiUtil.containingClass import org.jetbrains.kotlin.psi.psiUtil.referenceExpression data class MultiRule( val name: String, val rules: List<String> = listOf() ) { operator fun contains(ruleName: String) = ruleName in this.rules } private val multiRule = io.gitlab.arturbosch.detekt.api.MultiRule::class.simpleName ?: \"\" class MultiRuleCollector : Collector<MultiRule> { override val items = mutableListOf<MultiRule>() override fun visit(file: KtFile) { val visitor = MultiRuleVisitor() file.accept(visitor) if (visitor.containsMultiRule) { items.add(visitor.getMultiRule()) } } } class MultiRuleVisitor : DetektVisitor() { val containsMultiRule get() = classesMap.any { it.value } private var classesMap = mutableMapOf<String, Boolean>() private var name = \"\" private val rulesVisitor = RuleListVisitor() private val properties: MutableMap<String, String> = mutableMapOf() fun getMultiRule(): MultiRule { val rules = mutableListOf<String>() val ruleProperties = rulesVisitor.ruleProperties .mapNotNull { properties[it] } rules.addAll(ruleProperties) rules.addAll(rulesVisitor.ruleNames) if (name.isEmpty()) { throw InvalidDocumentationException(\"MultiRule without name found.\") } if (rules.isEmpty()) { throw InvalidDocumentationException(\"MultiRule $name contains no rules.\") } return MultiRule(name, rules) } override fun visitSuperTypeList(list: KtSuperTypeList) { val isMultiRule = list.entries ?.mapNotNull { it.typeAsUser"}
{"text": "if ([obj isKindOfClass:[NSDictionary class]]) { id codeObject = [obj objectForKey:@\"code\"]; id messageObject = [obj objectForKey:@\"message\"]; if (codeObject && messageObject) { NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; if (messageObject) { userInfo[NSLocalizedDescriptionKey] = messageObject; } NSInteger code = [codeObject integerValue]; id timestamp = [obj objectForKey:@\"timestamp\"]; if (timestamp) { userInfo[@\"timestamp\"] = timestamp; } [errorItems addObject:[NSError errorWithDomain:TAPIErrorDomain code:code userInfo:userInfo]]; successfullyParsedError = YES; } } if (!successfullyParsedError) { NSLog(@\"Failed to parse server error:[%@]\", obj); } }]; } } return errorItems; }<s><start> /* * Copyright (C) 2014 Saravan Pantham * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.psaravan.filebrowserview.lib.AsyncTasks; import android.app.ProgressDialog; import android.content.Context; import android.content.DialogInterface; import android.content.DialogInterface.OnClickListener; import android.os.AsyncTask; import android.widget.Toast; import com.psaravan.filebrowserview.lib.Interfaces.MoveInterface; import com.psaravan.filebrowserview.lib.R; import org.apache.commons.io.FileUtils; import java.io.File; /** * AsyncTask that moves the specified file/folder recursively to a new location. * * @author Saravan Pantham */ public class AsyncMoveTask extends AsyncTask<String, Void, Boolean> { private Context mContext; private Progress"}
{"text": "Type?.referencedName } ?.any { it == multiRule } ?: false val containingClass = list.containingClass() val className = containingClass?.name if (containingClass != null && className != null && !classesMap.containsKey(className)) { classesMap[className] = isMultiRule } super.visitSuperTypeList(list) } override fun visitClassOrObject(classOrObject: KtClassOrObject) { super.visitClassOrObject(classOrObject) if (classesMap[classOrObject.name] != true) { return } name = classOrObject.name?.trim() ?: \"\" } override fun visitProperty(property: KtProperty) { super.visitProperty(property) if (classesMap[property.containingClass()?.name] != true) { return } if (property.isOverride() && property.name != null && property.name == \"rules\") { property.accept(rulesVisitor) } else { val name = property.name val initializer = property.initializer?.referenceExpression()?.text if (name != null && initializer != null) { properties[name] = initializer } } } } class RuleListVisitor : DetektVisitor() { var ruleNames: MutableSet<String> = mutableSetOf() private set var ruleProperties: MutableSet<String> = mutableSetOf() private set override fun visitValueArgumentList(list: KtValueArgumentList) { super.visitValueArgumentList(list) val argumentExpressions = list.arguments.map { it.getArgumentExpression() } // Call Expression = Constructor of rule ruleNames.addAll(argumentExpressions .filterIsInstance<KtCallExpression>() .map { it.calleeExpression?.text ?: \"\" }) // Reference Expression = variable we need to search for ruleProperties.addAll(argumentExpressions .filterIsInstance<KtReferenceExpression>() .map { it.text ?: \"\" }) } }<s><start> /** * ScriptDev2 is an extension for mangos providing enhanced features for * area triggers, creatures, game objects, instances, items, and spells beyond * the default database scripting in mangos. * * Copyright (C) 2006-2013 ScriptDev2 <http://www.scriptdev2.com/> * * This program is free software"}
{"text": "Dialog pd; private File mSourceFile; private File mDestDirFile; private boolean mShowProgress = true; private MoveInterface mMoveInterface; public AsyncMoveTask(Context context, File source, File destDir, boolean showProgress) { mContext = context; mSourceFile = source; mShowProgress = showProgress; mDestDirFile = destDir; } @Override protected void onPreExecute() { if (mSourceFile==null) return; //Skip the rest of this method if the user doesn't want a progress dialog. if (!mShowProgress) return; pd = new ProgressDialog(mContext); pd.setCancelable(false); pd.setIndeterminate(false); pd.setTitle(R.string.move); pd.setMessage(mContext.getResources().getString(R.string.moving) + \" \" + mSourceFile.getName()); pd.setButton(DialogInterface.BUTTON_NEUTRAL, mContext.getResources() .getString(R.string.run_in_background), new OnClickListener() { @Override public void onClick(DialogInterface arg0, int arg1) { pd.dismiss(); } }); pd.show(); if (mMoveInterface!=null) mMoveInterface.preMoveStartSync(); } @Override protected Boolean doInBackground(String... params) { if (mMoveInterface!=null) mMoveInterface.preMoveStartAsync(); if (mSourceFile==null || mDestDirFile==null) { if (mMoveInterface!=null) mMoveInterface.onMoveCompleteAsync(false); return false; } if (mSourceFile.isDirectory()) { try { FileUtils.moveDirectory(mSourceFile, mDestDirFile); } catch (Exception e) { if (mMoveInterface!=null) mMoveInterface.onMoveCompleteAsync(false); return false; } } else { try { FileUtils.moveFile(mSourceFile, mDestDirFile); } catch (Exception e) { if (mMoveInterface!=null) mMoveInterface.onMoveCompleteAsync(false); return false; } } if (mMoveInterface!=null) mMoveInterface.onMoveCompleteAsync(true); return true; } @Override protected void onPostExecute(Boolean result) { super.onPostExecute(result); if (mMoveInterface!=null) mMoveInterface.on"}
{"text": "; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA * * World of Warcraft, and all World of Warcraft or Warcraft art, images, * and lore are copyrighted by Blizzard Entertainment, Inc. */ /** * ScriptData * SDName: bug_trio * SD%Complete: 75 * SDComment: Summon Player spell NYI; Poison Cloud damage spell NYI; Timers need adjustments * SDCategory: Temple of Ahn'Qiraj * EndScriptData */ #include \"precompiled.h\" #include \"temple_of_ahnqiraj.h\" enum { // kri SPELL_CLEAVE = 26350, SPELL_TOXIC_VOLLEY = 25812, SPELL_SUMMON_CLOUD = 26590, // summons 15933 // vem SPELL_CHARGE = 26561, SPELL_VENGEANCE = 25790, SPELL_KNOCKBACK = 26027, // yauj SPELL_HEAL = 25807, SPELL_FEAR = 26580, NPC_YAUJ_BROOD = 15621 }; struct MANGOS_DLL_DECL boss_kriAI : public ScriptedAI { boss_kriAI(Creature* pCreature) :"}
{"text": "MoveCompleteSync(result); if (pd!=null) pd.dismiss(); if (result==true) { String message = mSourceFile.getName() + \" \" + mContext.getResources().getString(R.string.moved); Toast.makeText(mContext, message, Toast.LENGTH_SHORT).show(); } else { String message = mSourceFile.getName() + \" \" + mContext.getResources().getString(R.string.could_not_be_moved); Toast.makeText(mContext, message, Toast.LENGTH_SHORT).show(); } } /** * @param moveInterface The move interface instance to attach to this * AsyncTask. */ public void setMoveInterface(MoveInterface moveInterface) { mMoveInterface = moveInterface; } }<s><start> <?php /* * This file is part of the Monolog package. * * (c) Jordi Boggiano <j.boggiano@seld.be> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */ namespace Monolog\\Handler; use Monolog\\TestCase; use Monolog\\Logger; class BufferHandlerTest extends TestCase { private $shutdownCheckHandler; /** * @covers Monolog\\Handler\\BufferHandler::__construct * @covers Monolog\\Handler\\BufferHandler::handle * @covers Monolog\\Handler\\BufferHandler::close */ public function testHandleBuffers() { $test = new TestHandler(); $handler = new BufferHandler($test); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::INFO)); $this->assertFalse($test->hasDebugRecords()); $this->assertFalse($test->hasInfoRecords()); $handler->close(); $this->assertTrue($test->hasInfoRecords()); $this->assertTrue(count($test->getRecords()) === 2); } /** * @covers Monolog\\Handler\\BufferHandler::close * @covers Monolog\\Handler\\BufferHandler::flush */ public function testPropagatesRecordsAtEndOfRequest() { $test = new TestHandler(); $handler = new BufferHandler($test); $handler->handle($this->getRecord(Logger::WARNING)); $handler->handle($this->getRecord(Logger"}
{"text": "ScriptedAI(pCreature) { m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData(); Reset(); } ScriptedInstance* m_pInstance; uint32 m_uiCleaveTimer; uint32 m_uiToxicVolleyTimer; void Reset() override { m_uiCleaveTimer = urand(4000, 8000); m_uiToxicVolleyTimer = urand(6000, 12000); } void JustDied(Unit* /*pKiller*/) override { // poison cloud on death DoCastSpellIfCan(m_creature, SPELL_SUMMON_CLOUD, CAST_TRIGGERED); if (!m_pInstance) { return; } // If the other 2 bugs are still alive, make unlootable if (m_pInstance->GetData(TYPE_BUG_TRIO) != DONE) { m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE); m_pInstance->SetData(TYPE_BUG_TRIO, SPECIAL); } } void JustReachedHome() override { if (m_pInstance) { m_pInstance->SetData(TYPE_BUG_TRIO, FAIL); } } void UpdateAI(const uint32 uiDiff) override { // Return since we have no target if (!m_creature->SelectHostileTarget() || !m_creature->getVictim()) { return; } // Cleave_Timer if (m_uiCleaveTimer < uiDiff) { if (DoCastSpellIfCan(m_creature->getVictim(), SPELL_CLEAVE) == CAST_OK) { m_uiCleaveTimer = urand(5000, 12000); } } else { m_uiCleaveTimer -= uiDiff; } // ToxicVolley_Timer if (m_uiToxicVolleyTimer < uiDiff) { if (DoCastSpellIfCan(m_creature, SPELL_TOXIC_VOLLEY) == CAST_OK) { m_uiToxicVol"}
{"text": "::DEBUG)); $this->shutdownCheckHandler = $test; register_shutdown_function(array($this, 'checkPropagation')); } public function checkPropagation() { if (!$this->shutdownCheckHandler->hasWarningRecords() || !$this->shutdownCheckHandler->hasDebugRecords()) { echo '!!! BufferHandlerTest::testPropagatesRecordsAtEndOfRequest failed to verify that the messages have been propagated' . PHP_EOL; exit(1); } } /** * @covers Monolog\\Handler\\BufferHandler::handle */ public function testHandleBufferLimit() { $test = new TestHandler(); $handler = new BufferHandler($test, 2); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::INFO)); $handler->handle($this->getRecord(Logger::WARNING)); $handler->close(); $this->assertTrue($test->hasWarningRecords()); $this->assertTrue($test->hasInfoRecords()); $this->assertFalse($test->hasDebugRecords()); } /** * @covers Monolog\\Handler\\BufferHandler::handle */ public function testHandleBufferLimitWithFlushOnOverflow() { $test = new TestHandler(); $handler = new BufferHandler($test, 3, Logger::DEBUG, true, true); // send two records $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::DEBUG)); $this->assertFalse($test->hasDebugRecords()); $this->assertCount(0, $test->getRecords()); // overflow $handler->handle($this->getRecord(Logger::INFO)); $this->assertTrue($test->hasDebugRecords()); $this->assertCount(3, $test->getRecords()); // should buffer again $handler->handle($this->getRecord(Logger::WARNING)); $this->assertCount(3, $test->getRecords()); $handler->close(); $this->assertCount(5, $test->getRecords()); $this->assertTrue($test->hasWarningRecords()); $this->assertTrue($test->hasInfoRecords());"}
{"text": "leyTimer = urand(10000, 15000); } } else { m_uiToxicVolleyTimer -= uiDiff; } DoMeleeAttackIfReady(); } }; struct MANGOS_DLL_DECL boss_vemAI : public ScriptedAI { boss_vemAI(Creature* pCreature) : ScriptedAI(pCreature) { m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData(); Reset(); } ScriptedInstance* m_pInstance; uint32 m_uiChargeTimer; uint32 m_uiKnockBackTimer; void Reset() override { m_uiChargeTimer = urand(15000, 27000); m_uiKnockBackTimer = urand(8000, 20000); } void JustDied(Unit* /*pKiller*/) override { // Enrage the other bugs DoCastSpellIfCan(m_creature, SPELL_VENGEANCE, CAST_TRIGGERED); if (!m_pInstance) { return; } // If the other 2 bugs are still alive, make unlootable if (m_pInstance->GetData(TYPE_BUG_TRIO) != DONE) { m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE); m_pInstance->SetData(TYPE_BUG_TRIO, SPECIAL); } } void JustReachedHome() override { if (m_pInstance) { m_pInstance->SetData(TYPE_BUG_TRIO, FAIL); } } void UpdateAI(const uint32 uiDiff) override { // Return since we have no target if (!m_creature->SelectHostileTarget() || !m_creature->getVictim()) { return; } // Charge_Timer if (m_uiChargeTimer < uiDiff) { if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0)) { if (DoCastSpellIfCan(pTarget, SPELL_CHARGE)"}
{"text": "} /** * @covers Monolog\\Handler\\BufferHandler::handle */ public function testHandleLevel() { $test = new TestHandler(); $handler = new BufferHandler($test, 0, Logger::INFO); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::INFO)); $handler->handle($this->getRecord(Logger::WARNING)); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->close(); $this->assertTrue($test->hasWarningRecords()); $this->assertTrue($test->hasInfoRecords()); $this->assertFalse($test->hasDebugRecords()); } /** * @covers Monolog\\Handler\\BufferHandler::flush */ public function testFlush() { $test = new TestHandler(); $handler = new BufferHandler($test, 0); $handler->handle($this->getRecord(Logger::DEBUG)); $handler->handle($this->getRecord(Logger::INFO)); $handler->flush(); $this->assertTrue($test->hasInfoRecords()); $this->assertTrue($test->hasDebugRecords()); $this->assertFalse($test->hasWarningRecords()); } /** * @covers Monolog\\Handler\\BufferHandler::handle */ public function testHandleUsesProcessors() { $test = new TestHandler(); $handler = new BufferHandler($test); $handler->pushProcessor(function ($record) { $record['extra']['foo'] = true; return $record; }); $handler->handle($this->getRecord(Logger::WARNING)); $handler->flush(); $this->assertTrue($test->hasWarningRecords()); $records = $test->getRecords(); $this->assertTrue($records[0]['extra']['foo']); } }<s><start> tparadox.png tparadox_150.png tparadox_200.png<s><start> { \"type\": \"minecraft:crafting_shaped\", \"pattern\": [ \"X \", \"XX \", \"XXX\" ], \"key\": { \"X\": { \"item\": \"tfc:wood/planks/douglas_fir\" } }, \"result\": { \"item\": \"tfc:stairs/wood/douglas_fir\", \"count\": 8 } }<s><start> diff --git a/"}
{"text": "== CAST_OK) { m_uiChargeTimer = urand(8000, 16000); } } } else { m_uiChargeTimer -= uiDiff; } // KnockBack_Timer if (m_uiKnockBackTimer < uiDiff) { if (DoCastSpellIfCan(m_creature, SPELL_KNOCKBACK) == CAST_OK) { if (m_creature->GetThreatManager().getThreat(m_creature->getVictim())) { m_creature->GetThreatManager().modifyThreatPercent(m_creature->getVictim(), -80); } m_uiKnockBackTimer = urand(15000, 25000); } } else { m_uiKnockBackTimer -= uiDiff; } DoMeleeAttackIfReady(); } }; struct MANGOS_DLL_DECL boss_yaujAI : public ScriptedAI { boss_yaujAI(Creature* pCreature) : ScriptedAI(pCreature) { m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData(); Reset(); } ScriptedInstance* m_pInstance; uint32 m_uiHealTimer; uint32 m_uiFearTimer; void Reset() override { m_uiHealTimer = urand(25000, 40000); m_uiFearTimer = urand(12000, 24000); } void JustDied(Unit* /*Killer*/) override { // Spawn 10 yauj brood on death float fX, fY, fZ; for (int i = 0; i < 10; ++i) { m_creature->GetRandomPoint(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), 10.0f, fX, fY, fZ); m_creature->SummonCreature(NPC_YAUJ_BROOD, fX, fY, fZ, 0.0f, TEMPSUMMON_"}
{"text": "README b/README index 2f68e14..262822a 100644 --- a/README +++ b/README @@ -1,3 +1,38 @@ +This is an Nginx fork that adds dtrace USDT probes. -Documentation is available at http://nginx.org +Installation: + + ./configure --with-dtrace-probes \\ + --with-dtrace=/usr/sbin/dtrace \\ + ... + make + make install + +Usage on Linux (with systemtap): + + # make the stap-nginx script visiable in your PATH + export PATH=/usr/local/nginx/sbin:$PATH + + # list all the static probes available in your nginx + stap-nginx -L 'process(\"nginx\").mark(\"*\")' + + # run the test.stp file + stap-nginx test.stp + +Sample test.stp file: + + probe begin + { + print(\"Tracing. Hit CTRL-C to stop.\\n\") + } + + probe process(\"nginx\").mark(\"http-subrequest-start\") + { + printf(\"uri: %s?%s\\n\", ngx_http_req_uri($arg1), + ngx_http_req_args($arg1)) + } + +For now, only tested on Solaris 11 Express and Fedora Linux 17. + +The original Nginx documentation is available at http://nginx.org diff --git a/auto/install b/auto/install index f7f686c..d6bc457 100644 --- a/auto/install +++ b/auto/install @@ -16,6 +16,20 @@ END fi +case \".$NGX_STAP_NGX_PATH\" in + ./*) + ;; + + .) + NGX_STAP_NGX_PATH=$NGX_PREFIX/sbin/stap-nginx + ;; + + *) + NGX_STAP_NGX_PATH=$NGX_PREFIX/$NGX_STAP_NGX_PATH + ;; +esac + + case \".$NGX_SBIN_PATH\" in ."}
{"text": "TIMED_OOC_DESPAWN, 30000); } if (!m_pInstance) { return; } // If the other 2 bugs are still alive, make unlootable if (m_pInstance->GetData(TYPE_BUG_TRIO) != DONE) { m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE); m_pInstance->SetData(TYPE_BUG_TRIO, SPECIAL); } } void JustReachedHome() override { if (m_pInstance) { m_pInstance->SetData(TYPE_BUG_TRIO, FAIL); } } void UpdateAI(const uint32 uiDiff) override { // Return since we have no target if (!m_creature->SelectHostileTarget() || !m_creature->getVictim()) { return; } // Fear_Timer if (m_uiFearTimer < uiDiff) { if (DoCastSpellIfCan(m_creature, SPELL_FEAR) == CAST_OK) { DoResetThreat(); m_uiFearTimer = 20000; } } else { m_uiFearTimer -= uiDiff; } // Heal if (m_uiHealTimer < uiDiff) { if (Unit* pTarget = DoSelectLowestHpFriendly(100.0f)) { if (DoCastSpellIfCan(pTarget, SPELL_HEAL) == CAST_OK) { m_uiHealTimer = urand(15000, 30000); } } } else { m_uiHealTimer -= uiDiff; } DoMeleeAttackIfReady(); } }; CreatureAI* GetAI_boss_yauj(Creature* pCreature) { return new boss_yaujAI(pCreature); } CreatureAI* GetAI_boss_vem(Creature* pCreature) { return new boss_vemAI(pCreature); } CreatureAI* GetAI_boss_kri(Creature* pCreature) { return new boss_kriAI(pCre"}
{"text": "/*) ;; @@ -49,6 +63,16 @@ case \".$NGX_PID_PATH\" in esac +case \".$NGX_TAPSET_PREFIX\" in + ./* | .) + ;; + + *) + NGX_TAPSET_PREFIX=$NGX_PREFIX/$NGX_TAPSET_PREFIX + ;; +esac + + case \".$NGX_ERROR_LOG_PATH\" in ./* | .) ;; @@ -147,6 +171,36 @@ install: $NGX_OBJS${ngx_dirsep}nginx${ngx_binext} \\ || cp -R $NGX_HTML '\\$(DESTDIR)$NGX_PREFIX' END +if [ $NGX_DTRACE = YES -a $DTRACE_FROM_SYSTEMTAP = YES ]; then + + ngx_tapset_srcs=\"$NGX_TAPSET_SRCS\" + + cat << END >> $NGX_MAKEFILE + test -d '\\$(DESTDIR)$NGX_TAPSET_PREFIX' || \\ + mkdir -p '\\$(DESTDIR)$NGX_TAPSET_PREFIX' +END + + for ngx_tapset_src in $ngx_tapset_srcs + do + ngx_tapset_file=`basename $ngx_tapset_src` + + cat << END >> $NGX_MAKEFILE + + sed -e \"s|NGX_SBIN_PATH|$NGX_SBIN_PATH|g\" $ngx_long_cont \\ + $ngx_tapset_src > '\\$(DESTDIR)$NGX_TAPSET_PREFIX/$ngx_tapset_file' +END + + done + + cat << END >> $NGX_MAKEFILE + + test -d '\\$(DESTDIR)`dirname \"$NGX_STAP_NGX_PATH\"`' || \\ + mkdir -p '\\$(DESTDIR)`dirname \"$NGX_STAP_NGX_PATH\"`' + cp $NGX_OBJS/stap-nginx '\\$(DESTDIR)$NGX_STAP_NGX_PATH' +"}
{"text": "ature); } void AddSC_bug_trio() { Script* pNewScript; pNewScript = new Script; pNewScript->Name = \"boss_kri\"; pNewScript->GetAI = &GetAI_boss_kri; pNewScript->RegisterSelf(); pNewScript = new Script; pNewScript->Name = \"boss_vem\"; pNewScript->GetAI = &GetAI_boss_vem; pNewScript->RegisterSelf(); pNewScript = new Script; pNewScript->Name = \"boss_yauj\"; pNewScript->GetAI = &GetAI_boss_yauj; pNewScript->RegisterSelf(); }<s><start> # Project-wide Gradle settings. # IDE (e.g. Android Studio) users: # Gradle settings configured through the IDE *will override* # any settings specified in this file. # For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. org.gradle.jvmargs=-Xmx1024m # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true<s><start> <html> <body> <h1>Directory listing</h1> <hr/> <pre> <a href=\"management-core-3.0.4-javadoc.jar\">management-core-3.0.4-javadoc.jar</a> <a href=\"management-core-3.0.4-javadoc.jar.md5\">management-core-3.0.4-javadoc.jar.md5</a> <a href=\"management-core-3.0.4-javadoc.jar.sha1\">management-core-3.0.4-javadoc.jar.sha1</a> <a href=\"management-core-3.0.4-sources.jar\">"}
{"text": "chmod 0755 '\\$(DESTDIR)$NGX_STAP_NGX_PATH' +END + +fi if test -n \"$NGX_ERROR_LOG_PATH\"; then cat << END >> $NGX_MAKEFILE @@ -158,6 +212,18 @@ END fi +if [ $NGX_DTRACE = YES ]; then + cat << END >> $NGX_MAKEFILE + +$NGX_OBJS${ngx_dirsep}stap-nginx: src/dtrace/stap-nginx + sed -e \"s|NGX_TAPSET_PREFIX|$NGX_TAPSET_PREFIX|g\" $ngx_long_cont \\ + -e \"s|NGX_SBIN_DIR|`dirname $NGX_SBIN_PATH`|g\" $ngx_long_cont \\ + -e \"s|NGX_SBIN_PATH|$NGX_SBIN_PATH|g\" $ngx_long_cont \\ + src/dtrace/stap-nginx > $NGX_OBJS${ngx_dirsep}stap-nginx +END +fi + + # create Makefile cat << END >> Makefile diff --git a/auto/make b/auto/make index dca011c..57ed99f 100644 --- a/auto/make +++ b/auto/make @@ -27,6 +27,9 @@ LINK = $LINK END +if [ $NGX_DTRACE = YES ]; then + echo DTRACE = $DTRACE >> $NGX_MAKEFILE +fi if test -n \"$NGX_PERL_CFLAGS\"; then echo NGX_PERL_CFLAGS = $NGX_PERL_CFLAGS >> $NGX_MAKEFILE @@ -204,6 +207,44 @@ ngx_objs=`echo $ngx_all_objs $ngx_modules_obj \\ | sed -e \"s/ *\\([^ ][^ ]*\\)/$ngx_long_regex_cont\\1/g\" \\ -e \"s/\\//$ngx_regex_dirsep"}
{"text": "management-core-3.0.4-sources.jar</a> <a href=\"management-core-3.0.4-sources.jar.md5\">management-core-3.0.4-sources.jar.md5</a> <a href=\"management-core-3.0.4-sources.jar.sha1\">management-core-3.0.4-sources.jar.sha1</a> <a href=\"management-core-3.0.4.jar\">management-core-3.0.4.jar</a> <a href=\"management-core-3.0.4.jar.md5\">management-core-3.0.4.jar.md5</a> <a href=\"management-core-3.0.4.jar.sha1\">management-core-3.0.4.jar.sha1</a> <a href=\"management-core-3.0.4.pom\">management-core-3.0.4.pom</a> <a href=\"management-core-3.0.4.pom.md5\">management-core-3.0.4.pom.md5</a> <a href=\"management-core-3.0.4.pom.sha1\">management-core-3.0.4.pom.sha1</a> </pre> </body> </html><s><start> package tk.woppo.sunday.model; import android.database.Cursor; import com.google.gson.Gson; import com.google.gson.annotations.SerializedName; import java.util.HashMap; import tk.woppo.sunday.dao.WeatherDataHelper; import tk.woppo.sunday.dao.WeatherTodayDataHelper; /** * Created by Ho on 2014/7/4. */ public class WeatherTodayModel extends BaseModel { private static final HashMap<String, WeatherTodayModel> CACHE = new HashMap<String, WeatherTodayModel>(); /** \u57ce\u5e02ID */ @SerializedName(\"cityid\") public String id; /** \u57ce\u5e02\u540d\u79f0 */ @SerializedName(\"city\") public String cityName; /** \u6e29\u5ea6 */ public"}
{"text": "/g\"` +if [ $NGX_DTRACE = YES ]; then + + ngx_dtrace_obj=$NGX_OBJS${ngx_dirsep}ngx_dtrace_provider.$ngx_objext + + ngx_dtrace_h=$NGX_OBJS${ngx_dirsep}ngx_dtrace_provider.h + + ngx_dtrace_d=$NGX_OBJS${ngx_dirsep}dtrace_providers.d + + ngx_dtrace_providers=`echo $NGX_DTRACE_PROVIDERS \\ + | sed -e \"s/ *\\([^ ][^ ]*\\)/$ngx_long_regex_cont\\1/g\" \\ + -e \"s/\\//$ngx_regex_dirsep/g\"` + + cat << END >> $NGX_MAKEFILE + +all: $NGX_OBJS${ngx_dirsep}nginx${ngx_binext} + +$ngx_dtrace_d: $ngx_dtrace_providers + cat $ngx_dtrace_providers > $ngx_dtrace_d + +$ngx_dtrace_h: $ngx_dtrace_d + \\$(DTRACE) -h -o $ngx_dtrace_h -s $ngx_dtrace_d +END + + if [ $DTRACE_PROBE_OBJ = YES ]; then + cat << END >> $NGX_MAKEFILE +$ngx_dtrace_obj: $ngx_dtrace_d $ngx_deps$ngx_spacer + \\$(DTRACE) -G -o $ngx_dtrace_obj -s $ngx_dtrace_d $ngx_objs +END + + ngx_deps=\"$ngx_deps$ngx_long_cont$ngx_dtrace_obj\" + ngx_objs=\"$ngx_objs$ngx_long_cont$ngx_dtrace_obj\" + + if [ \"$DTRACE_FROM_SYSTEMTAP\" = YES ]; then + ngx_deps=\"$ngx_deps$ngx_long_cont$NG"}
{"text": "String temp; /** \u5929\u6c14 */ public String weather; /** \u98ce\u5411 */ @SerializedName(\"WD\") public String wind; /** \u98ce\u529b */ @SerializedName(\"WS\") public String ws; /** \u6e7f\u5ea6 */ @SerializedName(\"SD\") public String sd; /** \u53d1\u5e03\u65f6\u95f4 */ public String time; private static void addToCache(WeatherTodayModel model) { CACHE.put(model.id, model); } private static WeatherTodayModel getFromCache(String id) { return CACHE.get(id); } public static WeatherTodayModel fromJson(String json) { return new Gson().fromJson(json, WeatherTodayModel.class); } public static WeatherTodayModel fromCursor(Cursor cursor) { String id = cursor.getString(cursor.getColumnIndex(WeatherDataHelper.WeatherDBInfo.ID)); WeatherTodayModel model = getFromCache(id); if (model != null) { return model; } model = new Gson().fromJson(cursor.getString(cursor.getColumnIndex(WeatherTodayDataHelper.WeatherTodayDBInfo.JSON)), WeatherTodayModel.class); addToCache(model); return model; } public static class WeatherTodayRequestData { public WeatherTodayModel weatherinfo; } }<s><start> /* * Copyright 2010-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved. * * Licensed under the Apache License, Version 2.0 (the \"License\"). * You may not use this file except in compliance with the License. * A copy of the License is located at * * http://aws.amazon.com/apache2.0 * * or in the \"license\" file accompanying this file. This file is distributed * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either * express or implied. See the License for the specific language governing * permissions and limitations under the License. */ #import \"SimpleDBMissingParameterException.h\" @implementation SimpleDBMissingParameterException @synthesize boxUsage; -(id)initWith"}
{"text": "X_OBJS${ngx_dirsep}stap-nginx\" + fi + fi +fi + if test -n \"$NGX_LD_OPT$CORE_LIBS\"; then ngx_libs=`echo $NGX_LD_OPT $CORE_LIBS \\ | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"` diff --git a/auto/options b/auto/options index cdf83ca..7f24765 100644 --- a/auto/options +++ b/auto/options @@ -12,6 +12,8 @@ NGX_CONF_PATH= NGX_ERROR_LOG_PATH= NGX_PID_PATH= NGX_LOCK_PATH= +NGX_TAPSET_PREFIX= +NGX_STAP_NGX_PATH= NGX_USER= NGX_GROUP= NGX_BUILD= @@ -21,6 +23,12 @@ CPP= NGX_OBJS=objs NGX_DEBUG=NO +NGX_DTRACE=NO +DTRACE=dtrace + +DTRACE_PROBE_OBJ=YES +DTRACE_FROM_SYSTEMTAP=NO + NGX_CC_OPT= NGX_LD_OPT= CPU=NO @@ -181,6 +189,8 @@ do --error-log-path=*) NGX_ERROR_LOG_PATH=\"$value\";; --pid-path=*) NGX_PID_PATH=\"$value\" ;; --lock-path=*) NGX_LOCK_PATH=\"$value\" ;; + --tapset-prefix=*) NGX_TAPSET_PREFIX=\"$value\" ;; + --stap-nginx-path=*) NGX_STAP_NGX_PATH=\"$value\" ;; --user=*) NGX_USER=\"$value\" ;; --group=*) NGX_GROUP=\"$value\" ;; @@ -305,7 +315,8 @@ use the \\\"--with-mail_ssl_module\\\" option instead\""}
{"text": "Message:(NSString *)theMessage { if (self = [super initWithMessage:theMessage]) { } return self; } -(void)setPropertiesWithException:(AmazonServiceException *)theException { [super setPropertiesWithException:theException]; if ([theException.additionalFields valueForKey:@\"BoxUsage\"] != nil) { self.boxUsage = [AmazonSDKUtil convertStringToNumber:[theException.additionalFields valueForKey:@\"BoxUsage\"]]; } } -(NSString *)description { NSMutableString *buffer = [[NSMutableString alloc] initWithCapacity:256]; [buffer appendString:@\"{\"]; [buffer appendString:[[[NSString alloc] initWithFormat:@\"BoxUsage: %@,\", boxUsage] autorelease]]; [buffer appendString:[super description]]; [buffer appendString:@\"}\"]; return [buffer autorelease]; } -(void)dealloc { [boxUsage release]; [super dealloc]; } @end<s><start> <?php /* * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE * OF TH"}
{"text": "--with-ld-opt=*) NGX_LD_OPT=\"$value\" ;; --with-cpu-opt=*) CPU=\"$value\" ;; --with-debug) NGX_DEBUG=YES ;; - + --with-dtrace=*) DTRACE=\"$value\" ;; + --with-dtrace-probes) NGX_DTRACE=YES ;; --without-pcre) USE_PCRE=DISABLED ;; --with-pcre) USE_PCRE=YES ;; --with-pcre=*) PCRE=\"$value\" ;; @@ -359,6 +370,8 @@ cat << END --error-log-path=PATH set error log pathname --pid-path=PATH set nginx.pid pathname --lock-path=PATH set nginx.lock pathname + --tapset-prefix=PATH set systemtap tapset directory prefix + --stap-nginx-path=PATH set stap-nginx pathname --user=USER set non-privileged user for worker processes @@ -506,6 +519,8 @@ cat << END --with-openssl-opt=OPTIONS set additional build options for OpenSSL --with-debug enable debug logging + --with-dtrace-probes enable dtrace USDT probes + --with-dtrace=PATH set dtrace utility pathname END @@ -536,6 +551,7 @@ NGX_CONF_PATH=${NGX_CONF_PATH:-conf/nginx.conf} NGX_CONF_PREFIX=`dirname $NGX_CONF_PATH` NGX_PID_PATH=${NGX_PID_PATH:-logs/nginx.pid} NGX_LOCK_PATH=${NGX_LOCK_PATH:-logs/nginx.lock} +NGX_TAPSET_PREFIX=${NGX_TAPSET_PREFIX:-tapset} if [ \".$NGX_ERROR_LOG_PATH\" = \".stderr\" ]; then NGX_ERROR_LOG_PATH= diff --git a/auto/os/darwin b/auto/os/darwin index 1d3e3d3..cb4ef3a 100644 --- a/auto/os/darwin +++"}
{"text": "IS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * This software consists of voluntary contributions made by many individuals * and is licensed under the LGPL. For more information, see * <http://www.doctrine-project.org>. */ namespace Doctrine\\ORM\\Internal\\Hydration; use Doctrine\\DBAL\\Connection; /** * Hydrator that produces flat, rectangular results of scalar data. * The created result is almost the same as a regular SQL result set, except * that column names are mapped to field names and data type conversions take place. * * @author Roman Borschel <roman@code-factory.org> * @since 2.0 */ class ScalarHydrator extends AbstractHydrator { /** @override */ protected function _hydrateAll() { $result = array(); $cache = array(); while ($data = $this->_stmt->fetch(\\PDO::FETCH_ASSOC)) { $result[] = $this->_gatherScalarRowData($data, $cache); } return $result; } /** @override */ protected function _hydrateRow(array $data, array &$cache, array &$result) { $result[] = $this->_gatherScalarRowData($data, $cache); } }<s><start> package network // Copyright (c) Microsoft and contributors. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // // See the License for the specific language governing permissions and // limitations under the License. // // Code generated by Microsoft (R) AutoRest Code Generator. // Changes may cause incorrect behavior and will be lost if the code is regenerated. import ( \"context\" \"github.com/Azure/go-autor"}
{"text": "b/auto/os/darwin @@ -113,3 +113,6 @@ ngx_feature_libs= ngx_feature_test=\"int32_t lock, n; n = OSAtomicCompareAndSwap32Barrier(0, 1, &lock)\" . auto/feature + +DTRACE_PROBE_OBJ=NO + diff --git a/auto/os/freebsd b/auto/os/freebsd index 937ca20..d76b32b 100644 --- a/auto/os/freebsd +++ b/auto/os/freebsd @@ -105,3 +105,8 @@ if [ $version -ge 701000 ]; then echo \" + cpuset_setaffinity() found\" have=NGX_HAVE_CPUSET_SETAFFINITY . auto/have fi + +if [ $NGX_DTRACE = YES ]; then + NGX_LD_OPT=\"$NGX_LD_OPT -lelf\" +fi + diff --git a/auto/os/linux b/auto/os/linux index c932267..b5114d6 100644 --- a/auto/os/linux +++ b/auto/os/linux @@ -171,3 +171,5 @@ ngx_include=\"sys/vfs.h\"; . auto/include CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\" + +DTRACE_FROM_SYSTEMTAP=YES diff --git a/auto/sources b/auto/sources index 2abbc60..fa7157d 100644 --- a/auto/sources +++ b/auto/sources @@ -39,10 +39,16 @@ CORE_DEPS=\"src/core/nginx.h \\ src/core/ngx_resolver.h \\ src/core/ngx_open_file_cache.h \\ src/core/ngx_c"}
{"text": "est/autorest\" \"github.com/Azure/go-autorest/autorest/azure\" \"github.com/Azure/go-autorest/tracing\" \"net/http\" ) // VpnSitesClient is the network Client type VpnSitesClient struct { BaseClient } // NewVpnSitesClient creates an instance of the VpnSitesClient client. func NewVpnSitesClient(subscriptionID string) VpnSitesClient { return NewVpnSitesClientWithBaseURI(DefaultBaseURI, subscriptionID) } // NewVpnSitesClientWithBaseURI creates an instance of the VpnSitesClient client. func NewVpnSitesClientWithBaseURI(baseURI string, subscriptionID string) VpnSitesClient { return VpnSitesClient{NewWithBaseURI(baseURI, subscriptionID)} } // CreateOrUpdate creates a VpnSite resource if it doesn't exist else updates the existing VpnSite. // Parameters: // resourceGroupName - the resource group name of the VpnSite. // vpnSiteName - the name of the VpnSite being created or updated. // vpnSiteParameters - parameters supplied to create or update VpnSite. func (client VpnSitesClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, vpnSiteName string, vpnSiteParameters VpnSite) (result VpnSitesCreateOrUpdateFuture, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.CreateOrUpdate\") defer func() { sc := -1 if result.Response() != nil { sc = result.Response().StatusCode } tracing.EndSpan(ctx, sc, err) }() } req, err := client.CreateOrUpdatePreparer(ctx, resourceGroupName, vpnSiteName, vpnSiteParameters) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"CreateOrUpdate\", nil, \"Failure preparing request\") return } result, err = client.CreateOrUpdateSender(req) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"CreateOrUpdate\", result.Response(), \"Failure sending"}
{"text": "rypt.h \\ + src/core/ngx_core_probe.h \\ src/core/ngx_proxy_protocol.h \\ src/core/ngx_syslog.h\" +if [ $NGX_DTRACE = YES ]; then + CORE_DEPS=\"$CORE_DEPS objs/ngx_dtrace_provider.h\" +fi + + CORE_SRCS=\"src/core/nginx.c \\ src/core/ngx_log.c \\ src/core/ngx_palloc.c \\ @@ -91,13 +97,14 @@ OPENSSL_SRCS=\"src/event/ngx_event_openssl.c \\ EVENT_MODULES=\"ngx_events_module ngx_event_core_module\" -EVENT_INCS=\"src/event src/event/modules\" +EVENT_INCS=\"src/event src/event/modules src/http src/http/modules\" EVENT_DEPS=\"src/event/ngx_event.h \\ src/event/ngx_event_timer.h \\ src/event/ngx_event_posted.h \\ src/event/ngx_event_connect.h \\ - src/event/ngx_event_pipe.h\" + src/event/ngx_event_pipe.h \\ + src/event/ngx_event_probe.h\" EVENT_SRCS=\"src/event/ngx_event.c \\ src/event/ngx_event_timer.c \\ @@ -289,7 +296,8 @@ HTTP_DEPS=\"src/http/ngx_http.h \\ src/http/ngx_http_variables.h \\ src/http/ngx_http_script.h \\ src/http/ngx_http_upstream.h \\ - src/http/ngx_http_upstream_round_robin.h\" + src/http/ngx_http_upstream_round_robin.h \\ + src/http/ngx_http_probe.h\" HTTP_SRCS=\"src/http/ngx_http.c \\ src/http/ngx_http_core_module."}
{"text": "request\") return } return } // CreateOrUpdatePreparer prepares the CreateOrUpdate request. func (client VpnSitesClient) CreateOrUpdatePreparer(ctx context.Context, resourceGroupName string, vpnSiteName string, vpnSiteParameters VpnSite) (*http.Request, error) { pathParameters := map[string]interface{}{ \"resourceGroupName\": autorest.Encode(\"path\", resourceGroupName), \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), \"vpnSiteName\": autorest.Encode(\"path\", vpnSiteName), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsContentType(\"application/json; charset=utf-8\"), autorest.AsPut(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}\", pathParameters), autorest.WithJSON(vpnSiteParameters), autorest.WithQueryParameters(queryParameters)) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // CreateOrUpdateSender sends the CreateOrUpdate request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) CreateOrUpdateSender(req *http.Request) (future VpnSitesCreateOrUpdateFuture, err error) { var resp *http.Response resp, err = autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) if err != nil { return } future.Future, err = azure.NewFutureFromResponse(resp) return } // CreateOrUpdateResponder handles the response to the CreateOrUpdate request. The method always // closes the http.Response Body. func (client VpnSitesClient) CreateOrUpdateResponder(resp *http.Response) (result VpnSite, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK, http"}
{"text": "c \\ @@ -593,3 +601,8 @@ NGX_GOOGLE_PERFTOOLS_MODULE=ngx_google_perftools_module NGX_GOOGLE_PERFTOOLS_SRCS=src/misc/ngx_google_perftools_module.c NGX_CPP_TEST_SRCS=src/misc/ngx_cpp_test_module.cpp + +NGX_DTRACE_PROVIDERS=src/dtrace/nginx_provider.d + +NGX_TAPSET_SRCS=src/dtrace/nginx.stp + diff --git a/auto/summary b/auto/summary index 1be975d..a1b6109 100644 --- a/auto/summary +++ b/auto/summary @@ -71,6 +71,19 @@ else echo \" nginx logs errors to stderr\" fi +if [ $NGX_DTRACE = YES ]; then + cat << END + nginx dtrace static probes enabled +END + + if [ $DTRACE_FROM_SYSTEMTAP = YES ]; then + cat << END + nginx systemtap tapset prefix: \"$NGX_TAPSET_PREFIX\" + nginx systemtap wrapper script: \"$NGX_STAP_NGX_PATH\" +END + fi +fi + cat << END nginx http access log file: \"$NGX_HTTP_LOG_PATH\" nginx http client request body temporary files: \"$NGX_HTTP_CLIENT_TEMP_PATH\" diff --git a/configure b/configure index ceff15e..49223f8 100755 --- a/configure +++ b/configure @@ -23,6 +23,9 @@ if [ $NGX_DEBUG = YES ]; then have=NGX_DEBUG . auto/have fi +if [ $NGX_DTRACE = YES ]; then + have=NGX_DTRACE . auto/have +fi if test -z \"$NGX_PLATFORM\"; then echo \"checking for OS\" diff --git a/src/core/ngx_core_probe.h b"}
{"text": ".StatusCreated), autorest.ByUnmarshallingJSON(&result), autorest.ByClosing()) result.Response = autorest.Response{Response: resp} return } // Delete deletes a VpnSite. // Parameters: // resourceGroupName - the resource group name of the VpnSite. // vpnSiteName - the name of the VpnSite being deleted. func (client VpnSitesClient) Delete(ctx context.Context, resourceGroupName string, vpnSiteName string) (result VpnSitesDeleteFuture, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.Delete\") defer func() { sc := -1 if result.Response() != nil { sc = result.Response().StatusCode } tracing.EndSpan(ctx, sc, err) }() } req, err := client.DeletePreparer(ctx, resourceGroupName, vpnSiteName) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"Delete\", nil, \"Failure preparing request\") return } result, err = client.DeleteSender(req) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"Delete\", result.Response(), \"Failure sending request\") return } return } // DeletePreparer prepares the Delete request. func (client VpnSitesClient) DeletePreparer(ctx context.Context, resourceGroupName string, vpnSiteName string) (*http.Request, error) { pathParameters := map[string]interface{}{ \"resourceGroupName\": autorest.Encode(\"path\", resourceGroupName), \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), \"vpnSiteName\": autorest.Encode(\"path\", vpnSiteName), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsDelete(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers"}
{"text": "/src/core/ngx_core_probe.h new file mode 100644 index 0000000..91bf91e --- /dev/null +++ b/src/core/ngx_core_probe.h @@ -0,0 +1,25 @@ +#ifndef _NGX_CORE_PROBE_H_INCLUDED_ +#define _NGX_CORE_PROBE_H_INCLUDED_ + + +#include <ngx_config.h> +#include <ngx_core.h> +#include <ngx_event.h> + + +#if (NGX_DTRACE) + +#include <ngx_http.h> +#include <ngx_dtrace_provider.h> + +#define ngx_core_probe_create_pool_done(pool, size) \\ + NGINX_CREATE_POOL_DONE(pool, size) + +#else /* !(NGX_DTRACE) */ + +#define ngx_core_probe_create_pool_done(pool, size) + +#endif + + +#endif /* _NGX_CORE_PROBE_H_INCLUDED_ */ diff --git a/src/core/ngx_palloc.c b/src/core/ngx_palloc.c index ef4a647..49bb30b 100644 --- a/src/core/ngx_palloc.c +++ b/src/core/ngx_palloc.c @@ -7,6 +7,7 @@ #include <ngx_config.h> #include <ngx_core.h> +#include <ngx_core_probe.h> static void *ngx_palloc_block(ngx_pool_t *pool, size_t size); @@ -37,6 +38,8 @@ ngx_create_pool(size_t size, ngx_log_t *log) p->cleanup = NULL; p->log = log; + ngx_core_probe_create_pool_"}
{"text": "/Microsoft.Network/vpnSites/{vpnSiteName}\", pathParameters), autorest.WithQueryParameters(queryParameters)) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // DeleteSender sends the Delete request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) DeleteSender(req *http.Request) (future VpnSitesDeleteFuture, err error) { var resp *http.Response resp, err = autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) if err != nil { return } future.Future, err = azure.NewFutureFromResponse(resp) return } // DeleteResponder handles the response to the Delete request. The method always // closes the http.Response Body. func (client VpnSitesClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent), autorest.ByClosing()) result.Response = resp return } // Get retrieves the details of a VPNsite. // Parameters: // resourceGroupName - the resource group name of the VpnSite. // vpnSiteName - the name of the VpnSite being retrieved. func (client VpnSitesClient) Get(ctx context.Context, resourceGroupName string, vpnSiteName string) (result VpnSite, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.Get\") defer func() { sc := -1 if result.Response.Response != nil { sc = result.Response.Response.StatusCode } tracing.EndSpan(ctx, sc, err) }() } req, err := client.GetPreparer(ctx, resourceGroupName, vpnSiteName) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"Get\", nil, \"Failure preparing request\") return } resp, err := client.GetSender(req) if err != nil { result."}
{"text": "done(p, size); + return p; } diff --git a/src/dtrace/nginx.stp b/src/dtrace/nginx.stp new file mode 100644 index 0000000..e824daf --- /dev/null +++ b/src/dtrace/nginx.stp @@ -0,0 +1,299 @@ +/* tapset for nginx */ + + +function ngx_indent(n, delta) +{ + s = \"\" + for (i = 0; i < n; i++) { + s .= delta + } + + return s +} + + +function ngx_http_subreq_depth(r) +{ + depth = 0 + + for (pr = @cast(r, \"ngx_http_request_t\", \"NGX_SBIN_PATH\")->parent; + pr != 0; + pr = @cast(pr, \"ngx_http_request_t\", \"NGX_SBIN_PATH\")->parent) + { + depth++ + } + + return depth +} + + +function ngx_http_req_parent(r) +{ + return @cast(r, \"ngx_http_request_s\", \"NGX_SBIN_PATH\")->parent +} + + +/* retrieve the request uri string from the ngx_http_request_t pointer */ +function ngx_http_req_uri(r) +{ + len = @cast(r, \"ngx_http_request_s\", \"NGX_SBIN_PATH\")->uri->len + + if (len == 0) { + return \"\" + } + + return user_string_n(@cast(r, \"ngx_http_request_s\", \"NGX_SBIN_PATH\")->uri->data, len) +} + + +/* retrieve the request query string from the ngx_http_request_t pointer */ +function ngx_http_req_args(r) +{ + len = @cast(r, \"ngx_http_request_s\", \"NGX_SBIN_PATH\")->args->len + + if (len == 0) { + return \"\" + } + + return user_string_n"}
{"text": "Response = autorest.Response{Response: resp} err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"Get\", resp, \"Failure sending request\") return } result, err = client.GetResponder(resp) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"Get\", resp, \"Failure responding to request\") } return } // GetPreparer prepares the Get request. func (client VpnSitesClient) GetPreparer(ctx context.Context, resourceGroupName string, vpnSiteName string) (*http.Request, error) { pathParameters := map[string]interface{}{ \"resourceGroupName\": autorest.Encode(\"path\", resourceGroupName), \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), \"vpnSiteName\": autorest.Encode(\"path\", vpnSiteName), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsGet(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}\", pathParameters), autorest.WithQueryParameters(queryParameters)) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // GetSender sends the Get request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) GetSender(req *http.Request) (*http.Response, error) { return autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) } // GetResponder handles the response to the Get request. The method always // closes the http.Response Body. func (client VpnSitesClient) GetResponder(resp *http.Response) (result VpnSite, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK), autorest.By"}
{"text": "(@cast(r, \"ngx_http_request_s\", \"NGX_SBIN_PATH\")->args->data, len) +} + + +/* retrieve the first command name (or directive name) from + * the ngx_module_t pointer */ +function ngx_http_module_cmd(m) +{ + cmds = @cast(m, \"ngx_module_t\", \"NGX_SBIN_PATH\")->commands + if (cmds == 0) { + return \"\" + } + + len = @cast(cmds, \"ngx_command_t\", \"NGX_SBIN_PATH\")->name->len + + if (len == 0) { + return \"\" + } + + return user_string_n(@cast(cmds, \"ngx_command_t\", \"NGX_SBIN_PATH\")->name->data, len) +} + + +function ngx_chain_buf(cl) +{ + return @cast(cl, \"ngx_chain_t\", \"NGX_SBIN_PATH\")->buf +} + + +function ngx_chain_next(cl) +{ + return @cast(cl, \"ngx_chain_t\", \"NGX_SBIN_PATH\")->next +} + +function ngx_buf_tag(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->tag +} + +function ngx_buf_in_memory(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->temporary + || @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->memory + || @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->mmap +} + + +function ngx_buf_pos(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->pos +} + + +function ngx_buf_file_pos(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_"}
{"text": "UnmarshallingJSON(&result), autorest.ByClosing()) result.Response = autorest.Response{Response: resp} return } // List lists all the VpnSites in a subscription. func (client VpnSitesClient) List(ctx context.Context) (result ListVpnSitesResultPage, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.List\") defer func() { sc := -1 if result.lvsr.Response.Response != nil { sc = result.lvsr.Response.Response.StatusCode } tracing.EndSpan(ctx, sc, err) }() } result.fn = client.listNextResults req, err := client.ListPreparer(ctx) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"List\", nil, \"Failure preparing request\") return } resp, err := client.ListSender(req) if err != nil { result.lvsr.Response = autorest.Response{Response: resp} err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"List\", resp, \"Failure sending request\") return } result.lvsr, err = client.ListResponder(resp) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"List\", resp, \"Failure responding to request\") } return } // ListPreparer prepares the List request. func (client VpnSitesClient) ListPreparer(ctx context.Context) (*http.Request, error) { pathParameters := map[string]interface{}{ \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsGet(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnSites\", pathParameters), autorest.WithQueryParameters(queryParameters"}
{"text": "PATH\")->file_pos +} + + +function ngx_buf_last(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->last +} + + +function ngx_buf_file_last(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->file_last +} + + +function ngx_buf_end(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->end +} + + +function ngx_buf_in_file(b) +{ + return @cast(b, \"ngx_buf_t\", \"NGX_SBIN_PATH\")->in_file +} + + +function ngx_buf_last_buf(b) +{ + return @cast(b, \"ngx_buf_t\", \"/home/agentzh/git/lua-nginx-module/work/nginx/sbin/nginx\")->last_buf +} + + +function ngx_buf_last_in_chain(b) +{ + return @cast(b, \"ngx_buf_t\", \"/home/agentzh/git/lua-nginx-module/work/nginx/sbin/nginx\")->last_in_chain +} + + +function ngx_buf_sync(b) +{ + return @cast(b, \"ngx_buf_t\", \"/home/agentzh/git/lua-nginx-module/work/nginx/sbin/nginx\")->sync +} + + +function ngx_buf_flush(b) +{ + return @cast(b, \"ngx_buf_t\", \"/home/agentzh/git/lua-nginx-module/work/nginx/sbin/nginx\")->flush +} + + +function ngx_buf_size(b) +{ + if (ngx_buf_in_memory(b)) { + return ngx_buf_last(b) - ngx_buf_pos(b) + } + + return ngx_buf_file_last(b) - ngx_buf_file_pos(b) +} + + +"}
{"text": ")) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // ListSender sends the List request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) ListSender(req *http.Request) (*http.Response, error) { return autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) } // ListResponder handles the response to the List request. The method always // closes the http.Response Body. func (client VpnSitesClient) ListResponder(resp *http.Response) (result ListVpnSitesResult, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK), autorest.ByUnmarshallingJSON(&result), autorest.ByClosing()) result.Response = autorest.Response{Response: resp} return } // listNextResults retrieves the next set of results, if any. func (client VpnSitesClient) listNextResults(ctx context.Context, lastResults ListVpnSitesResult) (result ListVpnSitesResult, err error) { req, err := lastResults.listVpnSitesResultPreparer(ctx) if err != nil { return result, autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listNextResults\", nil, \"Failure preparing next results request\") } if req == nil { return } resp, err := client.ListSender(req) if err != nil { result.Response = autorest.Response{Response: resp} return result, autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listNextResults\", resp, \"Failure sending next results request\") } result, err = client.ListResponder(resp) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listNextResults\", resp, \"Failure responding to next results request\") } return } // ListComplete enumerates all values, automatically crossing page boundaries as required. func (client VpnSitesClient) ListComplete(ctx context.Context) (result ListVpnSitesResultIterator, err error) {"}
{"text": "function ngx_buf_data(b) +{ + return user_string_n(ngx_buf_pos(b), ngx_buf_last(b) - ngx_buf_pos(b)) +} + + +function ngx_chain_writer_ctx_out(ctx) +{ + return @cast(c, \"ngx_chain_writer_ctx_t\", \"NGX_SBIN_PATH\")->out +} + + +function ngx_chain_dump:string (input) +{ + if (input == 0) { + return \"NULL\" + } + + out = \"\" + cl = input + while (cl) { + buf = ngx_chain_buf(cl) + + if (ngx_buf_in_memory(buf)) { + out .= sprintf(\"[%s]\", text_str(ngx_buf_data(buf))) + + } else { + out .= \"\\\"\\\"\" + } + + if (ngx_buf_in_file(buf)) { + out .= sprintf(\"<in_file:%d-%d>\", ngx_buf_file_pos(buf), + ngx_buf_file_last(buf)) + } + + if (ngx_buf_last_buf(buf)) { + out .= \"<last_buf>\" + } + + if (ngx_buf_last_in_chain(buf)) { + out .= \"<last_in_chain>\" + } + + if (ngx_buf_sync(buf)) { + out .= \"<sync>\" + } + + if (ngx_buf_flush(buf)) { + out .= \"<flush>\" + } + + tag = ngx_buf_tag(buf) + if (tag) { + out .= sprintf(\"<tag:%p>\", tag) + } + + cl = ngx_chain_next(cl) + if (cl) { + out .= \" \" + } + } + return out +} + + +function ngx_pool_cleanup_file_name(c) +{ + return user_string(@cast(c, \"ngx_pool_cleanup_file_t\", \"NGX_SBIN_PATH\")->name) +} + + +function ngx_http_req_content_length(r) +{"}
{"text": "if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.List\") defer func() { sc := -1 if result.Response().Response.Response != nil { sc = result.page.Response().Response.Response.StatusCode } tracing.EndSpan(ctx, sc, err) }() } result.page, err = client.List(ctx) return } // ListByResourceGroup lists all the vpnSites in a resource group. // Parameters: // resourceGroupName - the resource group name of the VpnSite. func (client VpnSitesClient) ListByResourceGroup(ctx context.Context, resourceGroupName string) (result ListVpnSitesResultPage, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.ListByResourceGroup\") defer func() { sc := -1 if result.lvsr.Response.Response != nil { sc = result.lvsr.Response.Response.StatusCode } tracing.EndSpan(ctx, sc, err) }() } result.fn = client.listByResourceGroupNextResults req, err := client.ListByResourceGroupPreparer(ctx, resourceGroupName) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"ListByResourceGroup\", nil, \"Failure preparing request\") return } resp, err := client.ListByResourceGroupSender(req) if err != nil { result.lvsr.Response = autorest.Response{Response: resp} err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"ListByResourceGroup\", resp, \"Failure sending request\") return } result.lvsr, err = client.ListByResourceGroupResponder(resp) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"ListByResourceGroup\", resp, \"Failure responding to request\") } return } // ListByResourceGroupPreparer prepares the ListByResourceGroup request. func (client VpnSitesClient) ListByResourceGroupPreparer(ctx context.Context, resourceGroupName string) (*http.Request"}
{"text": "+ return @cast(r, \"ngx_http_request_t\", \"NGX_SBIN_PATH\")->headers_in->content_length_n +} + + +function ngx_http_req_body_temp_file_name(r) +{ + rb = @cast(r, \"ngx_http_request_t\", \"NGX_SBIN_PATH\")->request_body + if (!rb) { + return \"\" + } + + tf = @cast(rb, \"ngx_http_request_body_t\", \"NGX_SBIN_PATH\")->temp_file + if (!tf) { + return \"\" + } + + len = @cast(tf, \"ngx_temp_file_t\", \"NGX_SBIN_PATH\")->file->name->len + + return user_string_n(@cast(tf, \"ngx_temp_file_t\", \"NGX_SBIN_PATH\")->file->name->data, len) +} + + +function ngx_table_elt_key(e) +{ + len = @cast(e, \"ngx_table_elt_t\", \"NGX_SBIN_PATH\")->key->len + + return user_string_n(@cast(e, \"ngx_table_elt_t\", \"NGX_SBIN_PATH\")->key->data, len) +} + + +function ngx_table_elt_value(e) +{ + len = @cast(e, \"ngx_table_elt_t\", \"NGX_SBIN_PATH\")->value->len + + return user_string_n(@cast(e, \"ngx_table_elt_t\", \"NGX_SBIN_PATH\")->value->data, len) +} + + +function ngx_iovec_dump:string (iov, iovcnt) { + out = \"\" + for (i = 0; i < iovcnt; i++) { + out .= sprintf(\"\\\"%s\\\"(%p)\", text_str(user_string_n( + @cast(iov, \"struct iovec\")[i]->iov_base, + @cast(iov, \"struct iovec\")[i]->iov_len)"}
{"text": ", error) { pathParameters := map[string]interface{}{ \"resourceGroupName\": autorest.Encode(\"path\", resourceGroupName), \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsGet(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites\", pathParameters), autorest.WithQueryParameters(queryParameters)) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // ListByResourceGroupSender sends the ListByResourceGroup request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) ListByResourceGroupSender(req *http.Request) (*http.Response, error) { return autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) } // ListByResourceGroupResponder handles the response to the ListByResourceGroup request. The method always // closes the http.Response Body. func (client VpnSitesClient) ListByResourceGroupResponder(resp *http.Response) (result ListVpnSitesResult, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK), autorest.ByUnmarshallingJSON(&result), autorest.ByClosing()) result.Response = autorest.Response{Response: resp} return } // listByResourceGroupNextResults retrieves the next set of results, if any. func (client VpnSitesClient) listByResourceGroupNextResults(ctx context.Context, lastResults ListVpnSitesResult) (result ListVpnSitesResult, err error) { req, err := lastResults.listVpnSitesResultPreparer(ctx) if err != nil { return result, autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listByResourceGroupNextResults"}
{"text": "+ ), @cast(iov, \"struct iovec\")[i]->iov_base) + if (i != iovcnt - 1) { + out .= \" \" + } + } + return out +} + diff --git a/src/dtrace/nginx_provider.d b/src/dtrace/nginx_provider.d new file mode 100644 index 0000000..5887ae7 --- /dev/null +++ b/src/dtrace/nginx_provider.d @@ -0,0 +1,40 @@ +typedef struct { int dummy; } ngx_http_request_t; +typedef struct { int dummy; } ngx_str_t; +typedef int64_t ngx_int_t; +typedef uint64_t ngx_uint_t; +typedef ngx_uint_t ngx_msec_t; +typedef struct { int dummy; } ngx_module_t; +typedef struct { int dummy; } ngx_http_module_t; +typedef struct { int dummy; } ngx_table_elt_t; +typedef struct { int dummy; } ngx_event_t; +typedef struct { int dummy; } ngx_pool_t; +typedef char unsigned u_char; + + +provider nginx { + /* probes for subrequests */ + probe http__subrequest__cycle(ngx_http_request_t *pr, ngx_str_t *uri, ngx_str_t *args); + probe http__subrequest__start(ngx_http_request_t *r); + probe http__subrequest__finalize_writing(ngx_http_request_t *r); + probe http__subrequest__finalize_nonactive(ngx_http_request_t *r); + probe http__subrequest__wake__parent(ngx_http_request_t *r); + probe http__subrequest__done(ngx_http_request_t *r); + probe http__subrequest__post__start(ngx_http_request_t *r, ng"}
{"text": "\", nil, \"Failure preparing next results request\") } if req == nil { return } resp, err := client.ListByResourceGroupSender(req) if err != nil { result.Response = autorest.Response{Response: resp} return result, autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listByResourceGroupNextResults\", resp, \"Failure sending next results request\") } result, err = client.ListByResourceGroupResponder(resp) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"listByResourceGroupNextResults\", resp, \"Failure responding to next results request\") } return } // ListByResourceGroupComplete enumerates all values, automatically crossing page boundaries as required. func (client VpnSitesClient) ListByResourceGroupComplete(ctx context.Context, resourceGroupName string) (result ListVpnSitesResultIterator, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.ListByResourceGroup\") defer func() { sc := -1 if result.Response().Response.Response != nil { sc = result.page.Response().Response.Response.StatusCode } tracing.EndSpan(ctx, sc, err) }() } result.page, err = client.ListByResourceGroup(ctx, resourceGroupName) return } // UpdateTags updates VpnSite tags. // Parameters: // resourceGroupName - the resource group name of the VpnSite. // vpnSiteName - the name of the VpnSite being updated. // vpnSiteParameters - parameters supplied to update VpnSite tags. func (client VpnSitesClient) UpdateTags(ctx context.Context, resourceGroupName string, vpnSiteName string, vpnSiteParameters TagsObject) (result VpnSitesUpdateTagsFuture, err error) { if tracing.IsEnabled() { ctx = tracing.StartSpan(ctx, fqdn+\"/VpnSitesClient.UpdateTags\") defer func() { sc := -1 if result.Response() != nil { sc = result.Response().StatusCode } tracing.EndSpan(ctx, sc, err) }() } req, err := client.UpdateTagsPreparer(ctx, resource"}
{"text": "x_int_t rc); + probe http__subrequest__post__done(ngx_http_request_t *r, ngx_int_t rc); + probe http__module__post__config(ngx_module_t *m); + probe http__read__body__done(ngx_http_request_t *r); + probe http__read__req__line__done(ngx_http_request_t *r); + probe http__read__req__header__done(ngx_http_request_t *r, ngx_table_elt_t *h); + probe timer__add(ngx_event_t *ev, ngx_msec_t timer); + probe timer__del(ngx_event_t *ev); + probe timer__expire(ngx_event_t *ev); + probe create__pool__done(ngx_pool_t *pool, size_t size); +}; + + +#pragma D attributes Evolving/Evolving/Common provider nginx provider +#pragma D attributes Private/Private/Unknown provider nginx module +#pragma D attributes Private/Private/Unknown provider nginx function +#pragma D attributes Private/Private/Common provider nginx name +#pragma D attributes Evolving/Evolving/Common provider nginx args + diff --git a/src/dtrace/stap-nginx b/src/dtrace/stap-nginx new file mode 100755 index 0000000..1bca4cf --- /dev/null +++ b/src/dtrace/stap-nginx @@ -0,0 +1,6 @@ +#!/bin/sh + +PATH=\"NGX_SBIN_DIR:$PATH\" +export PATH +exec stap -d \"NGX_SBIN_PATH\" -I \"NGX_TAPSET_PREFIX\" \"$@\" + diff --git a/src/event/ngx_event_probe.h b/src/event/ngx_event_probe.h new file mode 100644 index 0000000..5aa0397 --- /dev/null +++ b/src/event/ngx_event_pro"}
{"text": "GroupName, vpnSiteName, vpnSiteParameters) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"UpdateTags\", nil, \"Failure preparing request\") return } result, err = client.UpdateTagsSender(req) if err != nil { err = autorest.NewErrorWithError(err, \"network.VpnSitesClient\", \"UpdateTags\", result.Response(), \"Failure sending request\") return } return } // UpdateTagsPreparer prepares the UpdateTags request. func (client VpnSitesClient) UpdateTagsPreparer(ctx context.Context, resourceGroupName string, vpnSiteName string, vpnSiteParameters TagsObject) (*http.Request, error) { pathParameters := map[string]interface{}{ \"resourceGroupName\": autorest.Encode(\"path\", resourceGroupName), \"subscriptionId\": autorest.Encode(\"path\", client.SubscriptionID), \"vpnSiteName\": autorest.Encode(\"path\", vpnSiteName), } const APIVersion = \"2018-10-01\" queryParameters := map[string]interface{}{ \"api-version\": APIVersion, } preparer := autorest.CreatePreparer( autorest.AsContentType(\"application/json; charset=utf-8\"), autorest.AsPatch(), autorest.WithBaseURL(client.BaseURI), autorest.WithPathParameters(\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}\", pathParameters), autorest.WithJSON(vpnSiteParameters), autorest.WithQueryParameters(queryParameters)) return preparer.Prepare((&http.Request{}).WithContext(ctx)) } // UpdateTagsSender sends the UpdateTags request. The method will close the // http.Response Body if it receives an error. func (client VpnSitesClient) UpdateTagsSender(req *http.Request) (future VpnSitesUpdateTagsFuture, err error) { var resp *http.Response resp, err = autorest.SendWithSender(client, req, azure.DoRetryWithRegistration(client.Client)) if err != nil { return } future.Future, err = azure.NewFutureFromResponse("}
{"text": "be.h @@ -0,0 +1,33 @@ +#ifndef _NGX_EVENT_PROBE_H_INCLUDED_ +#define _NGX_EVENT_PROBE_H_INCLUDED_ + + +#include <ngx_config.h> +#include <ngx_core.h> +#include <ngx_event.h> + + +#if (NGX_DTRACE) + +#include <ngx_http.h> +#include <ngx_dtrace_provider.h> + +#define ngx_event_probe_timer_add(ev, timer) \\ + NGINX_TIMER_ADD(ev, timer) + +#define ngx_event_probe_timer_del(ev) \\ + NGINX_TIMER_DEL(ev) + +#define ngx_event_probe_timer_expire(ev) \\ + NGINX_TIMER_EXPIRE(ev) + +#else /* !(NGX_DTRACE) */ + +#define ngx_event_probe_timer_add(ev, timer) +#define ngx_event_probe_timer_del(ev) +#define ngx_event_probe_timer_expire(ev) + +#endif + + +#endif /* _NGX_EVENT_PROBE_H_INCLUDED_ */ diff --git a/src/event/ngx_event_timer.c b/src/event/ngx_event_timer.c index 8f547b2..6e77465 100644 --- a/src/event/ngx_event_timer.c +++ b/src/event/ngx_event_timer.c @@ -8,6 +8,7 @@ #include <ngx_config.h> #include <ngx_core.h> #include <ngx_event.h> +#include <ngx_event_probe.h> ngx_rbtree_t ngx_event_timer_rbtree; @@ -91,6 +92,"}
{"text": "resp) return } // UpdateTagsResponder handles the response to the UpdateTags request. The method always // closes the http.Response Body. func (client VpnSitesClient) UpdateTagsResponder(resp *http.Response) (result VpnSite, err error) { err = autorest.Respond( resp, client.ByInspecting(), azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated), autorest.ByUnmarshallingJSON(&result), autorest.ByClosing()) result.Response = autorest.Response{Response: resp} return }<s><start> 'use strict'; angular.module(\"ngLocale\", [], [\"$provide\", function($provide) { var PLURAL_CATEGORY = {ZERO: \"zero\", ONE: \"one\", TWO: \"two\", FEW: \"few\", MANY: \"many\", OTHER: \"other\"}; function getDecimals(n) { n = n + ''; var i = n.indexOf('.'); return (i == -1) ? 0 : n.length - i - 1; } function getVF(n, opt_precision) { var v = opt_precision; if (undefined === v) { v = Math.min(getDecimals(n), 3); } var base = Math.pow(10, v); var f = ((n * base) | 0) % base; return {v: v, f: f}; } $provide.value(\"$locale\", { \"DATETIME_FORMATS\": { \"AMPMS\": [ \"Dinda\", \"Dilolo\" ], \"DAY\": [ \"Lumingu\", \"Nkodya\", \"Nd\\u00e0ay\\u00e0\", \"Ndang\\u00f9\", \"Nj\\u00f2wa\", \"Ng\\u00f2vya\", \"Lubingu\" ], \"MONTH\": [ \"Ciongo\", \"L\\u00f9ishi\", \"Lus\\u00f2lo\", \"M\\u00f9uy\\u00e0\", \"Lum\\u00f9ng\\u00f9l\\u00f"}
{"text": "8 @@ ngx_event_expire_timers(void) ev->timedout = 1; + ngx_event_probe_timer_expire(ev); + ev->handler(ev); } } @@ -136,3 +139,19 @@ ngx_event_cancel_timers(void) ev->handler(ev); } } + + +#if (NGX_DTRACE) +void +ngx_event_probe_timer_add_helper(ngx_event_t *ev, ngx_msec_t timer) +{ + ngx_event_probe_timer_add(ev, timer); +} + + +void +ngx_event_probe_timer_del_helper(ngx_event_t *ev) +{ + ngx_event_probe_timer_del(ev); +} +#endif diff --git a/src/event/ngx_event_timer.h b/src/event/ngx_event_timer.h index 99f8a48..8bc619a 100644 --- a/src/event/ngx_event_timer.h +++ b/src/event/ngx_event_timer.h @@ -25,12 +25,23 @@ void ngx_event_expire_timers(void); void ngx_event_cancel_timers(void); +#if (NGX_DTRACE) +void ngx_event_probe_timer_add_helper(ngx_event_t *ev, + ngx_msec_t timer); +void ngx_event_probe_timer_del_helper(ngx_event_t *ev); +#endif + + extern ngx_rbtree_t ngx_event_timer_rbtree; static ngx_inline void ngx_event_del_timer(ngx_event_t *ev) { +#if (NGX_DTRACE) + ngx_event_probe_timer_del_helper(ev); +#endif + ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,"}
{"text": "9\", \"Lufuimi\", \"Kab\\u00e0l\\u00e0sh\\u00ecp\\u00f9\", \"L\\u00f9sh\\u00eck\\u00e0\", \"Lutongolo\", \"Lung\\u00f9di\", \"Kasw\\u00e8k\\u00e8s\\u00e8\", \"Cisw\\u00e0\" ], \"SHORTDAY\": [ \"Lum\", \"Nko\", \"Ndy\", \"Ndg\", \"Njw\", \"Ngv\", \"Lub\" ], \"SHORTMONTH\": [ \"Cio\", \"Lui\", \"Lus\", \"Muu\", \"Lum\", \"Luf\", \"Kab\", \"Lush\", \"Lut\", \"Lun\", \"Kas\", \"Cis\" ], \"fullDate\": \"EEEE d MMMM y\", \"longDate\": \"d MMMM y\", \"medium\": \"d MMM y HH:mm:ss\", \"mediumDate\": \"d MMM y\", \"mediumTime\": \"HH:mm:ss\", \"short\": \"d/M/y HH:mm\", \"shortDate\": \"d/M/y\", \"shortTime\": \"HH:mm\" }, \"NUMBER_FORMATS\": { \"CURRENCY_SYM\": \"FrCD\", \"DECIMAL_SEP\": \",\", \"GROUP_SEP\": \".\", \"PATTERNS\": [ { \"gSize\": 3, \"lgSize\": 3, \"maxFrac\": 3, \"minFrac\": 0, \"minInt\": 1, \"negPre\": \"-\", \"negSuf\": \"\", \"posPre\": \"\", \"posSuf\": \"\" }, { \"gSize\": 3, \"lgSize\": 3, \"maxFrac\": 2, \"minFrac\": 2, \"minInt\": 1, \"negPre\": \"-\", \"negSuf\": \"\\u00a4\", \"posPre\": \"\", \"posSuf\": \"\\u00a4\" } ] }, \"id\": \"lu-cd\", \"pluralCat\": function (n, opt_precision) {"}
{"text": "\"event timer del: %d: %M\", ngx_event_ident(ev->data), ev->timer.key); @@ -77,6 +88,10 @@ ngx_event_add_timer(ngx_event_t *ev, ngx_msec_t timer) ev->timer.key = key; +#if (NGX_DTRACE) + ngx_event_probe_timer_add_helper(ev, timer); +#endif + ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0, \"event timer add: %d: %M:%M\", ngx_event_ident(ev->data), timer, ev->timer.key); diff --git a/src/http/ngx_http.c b/src/http/ngx_http.c index d09e3f0..5ae35a7 100644 --- a/src/http/ngx_http.c +++ b/src/http/ngx_http.c @@ -8,6 +8,7 @@ #include <ngx_config.h> #include <ngx_core.h> #include <ngx_http.h> +#include <ngx_http_probe.h> static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); @@ -312,6 +313,9 @@ ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) module = ngx_modules[m]->ctx; if (module->postconfiguration) { + + ngx_http_probe_module_post_config(ngx_modules[m]); + if (module->postconfiguration(cf) != NGX_OK) { return NGX_CONF_ERROR; } diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c index 49c4560..808d1d8 100644 --- a/src"}
{"text": "var i = n | 0; var vf = getVF(n, opt_precision); if (i == 1 && vf.v == 0) { return PLURAL_CATEGORY.ONE; } return PLURAL_CATEGORY.OTHER;} }); }]);<s><start> package com.android.inputmethodcommon; class InputMethodSettingsInterface { } class InputMethodSettingsImpl { int mContext; int mImi; int mImm; int mSubtypeEnablerIcon; int mSubtypeEnablerIconRes; int mSubtypeEnablerTitle; int mSubtypeEnablerTitleRes; int mInputMethodSettingsCategoryTitle; int mInputMethodSettingsCategoryTitleRes; int mSubtypeEnablerPreference; } class InputMethodSettingsFragment { int mSettings; } class InputMethodSettingsActivity { int mSettings; }<s><start> <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/appBackground\" android:foreground=\"?android:attr/selectableItemBackground\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:paddingBottom=\"15dp\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" android:paddingTop=\"15dp\"> <ImageView android:id=\"@+id/song_item_img\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_weight=\"0\" /> <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"15dp\" android:layout_weight=\"1\" android:orientation=\"vertical\"> <TextView android:id=\"@+id/song_item_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:singleLine=\"true\" android:textColor=\"#000\" android:textSize=\"16sp\" /> <TextView android:id=\"@+id/song_item_artist\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:singleLine"}
{"text": "/http/ngx_http_core_module.c +++ b/src/http/ngx_http_core_module.c @@ -8,6 +8,7 @@ #include <ngx_config.h> #include <ngx_core.h> #include <ngx_http.h> +#include <ngx_http_probe.h> typedef struct { @@ -2431,6 +2432,8 @@ ngx_http_subrequest(ngx_http_request_t *r, ngx_http_postponed_request_t *pr, *p; if (r->subrequests == 0) { + ngx_http_probe_subrequest_cycle(r, uri, args); + ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"subrequests cycle while processing \\\"%V\\\"\", uri); return NGX_ERROR; @@ -2557,6 +2560,8 @@ ngx_http_subrequest(ngx_http_request_t *r, *psr = sr; + ngx_http_probe_subrequest_start(sr); + return ngx_http_post_request(sr, NULL); } diff --git a/src/http/ngx_http_probe.h b/src/http/ngx_http_probe.h new file mode 100644 index 0000000..d7d2d45 --- /dev/null +++ b/src/http/ngx_http_probe.h @@ -0,0 +1,75 @@ +#ifndef _NGX_HTTP_PROBE_H_INCLUDED_ +#define _NGX_HTTP_PROBE_H_INCLUDED_ + + +#include <ngx_config.h> +#include <ngx_core.h> +#include <ngx_http.h> + + +#if (NGX_DTRACE) + +#include <ngx_dtrace_provider.h> + +#define ngx_http_probe_subrequest_cycle("}
{"text": "=\"true\" android:textColor=\"#989898\" android:textSize=\"14sp\" /> </LinearLayout> <ImageView android:id=\"@+id/song_item_menu\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginRight=\"5dp\" android:layout_weight=\"0\" android:background=\"@drawable/unbounded_ripple\" android:foregroundTint=\"#434343\" android:padding=\"5dp\" android:src=\"@drawable/abc_ic_menu_moreoverflow_mtrl_alpha\" android:theme=\"@style/Theme.AppCompat.Light\" /> </LinearLayout><s><start> /*####################################################### * Copyright (c) 2014 Jeff Martin * Copyright (c) 2015 Pedro Lafuente * Copyright (c) 2017-2019 Gregor Santner * * Licensed under the MIT license. * You can get a copy of the license text here: * https://opensource.org/licenses/MIT ###########################################################*/ package other.writeily.ui; import android.app.Dialog; import android.os.Bundle; import android.support.annotation.NonNull; import android.support.v4.app.DialogFragment; import android.support.v7.app.AlertDialog; import android.text.TextUtils; import net.gsantner.markor.R; import net.gsantner.markor.util.AppSettings; import java.io.Serializable; public class WrConfirmDialog extends DialogFragment { public static final String FRAGMENT_TAG = \"WrConfirmDialog\"; private static final String EXTRA_TITLE = \"EXTRA_TITLE\"; private static final String EXTRA_MESSAGE = \"EXTRA_MESSAGE\"; public static final String EXTRA_DATA = \"EXTRA_DATA\"; private Serializable _data; private ConfirmDialogCallback[] _callbacks; private String _summary; public static WrConfirmDialog newInstance(String title, String message, Serializable data, ConfirmDialogCallback... callbacks) { WrConfirmDialog confirmDialog = new WrConfirmDialog(); Bundle args = new Bundle(); args.putSerializable(EXT"}
{"text": "pr, uri, args) \\ + NGINX_HTTP_SUBREQUEST_CYCLE(pr, uri, args) + +#define ngx_http_probe_subrequest_start(r) \\ + NGINX_HTTP_SUBREQUEST_START(r) + +#define ngx_http_probe_subrequest_finalize_writing(r) \\ + NGINX_HTTP_SUBREQUEST_FINALIZE_WRITING(r) + +#define ngx_http_probe_subrequest_finalize_nonactive(r) \\ + NGINX_HTTP_SUBREQUEST_FINALIZE_NONACTIVE(r) + +#define ngx_http_probe_subrequest_finalize_nonactive(r) \\ + NGINX_HTTP_SUBREQUEST_FINALIZE_NONACTIVE(r) + +#define ngx_http_probe_subrequest_wake_parent(r) \\ + NGINX_HTTP_SUBREQUEST_WAKE_PARENT(r) + +#define ngx_http_probe_subrequest_done(r) \\ + NGINX_HTTP_SUBREQUEST_DONE(r) + +#define ngx_http_probe_subrequest_post_start(r, rc) \\ + NGINX_HTTP_SUBREQUEST_POST_START(r, rc) + +#define ngx_http_probe_subrequest_post_done(r, rc) \\ + NGINX_HTTP_SUBREQUEST_POST_DONE(r, rc) + +#define ngx_http_probe_module_post_config(m) \\ + NGINX_HTTP_MODULE_POST_CONFIG(m) + +#define ngx_http_probe_read_body_abort(r, reason) \\ + NGINX_HTTP_READ_BODY_ABORT(r, reason) + +#define ngx_http_probe_read_body_done(r) \\ + NGINX_HTTP_READ_BODY_DONE(r) + +#define ngx_http_probe_read"}
{"text": "RA_DATA, data); args.putString(EXTRA_TITLE, title); args.putString(EXTRA_MESSAGE, message); confirmDialog.setArguments(args); confirmDialog.setCallbacks(callbacks); return confirmDialog; } public void setCallbacks(ConfirmDialogCallback[] callbacks) { _callbacks = callbacks; } @Override @NonNull public Dialog onCreateDialog(Bundle savedInstanceState) { String title = getArguments().getString(EXTRA_TITLE); String message = getArguments().getString(EXTRA_MESSAGE); _data = getArguments().getSerializable(EXTRA_DATA); AlertDialog.Builder dialogBuilder; boolean darkTheme = AppSettings.get().isDarkThemeEnabled(); dialogBuilder = new AlertDialog.Builder(getActivity(), darkTheme ? R.style.Theme_AppCompat_Dialog : R.style.Theme_AppCompat_Light_Dialog); dialogBuilder.setTitle(title); if (!TextUtils.isEmpty(message)) { dialogBuilder.setMessage(message); } dialogBuilder.setPositiveButton(getString(android.R.string.ok), (dialog, which) -> { if (_callbacks != null) { for (ConfirmDialogCallback cdc : _callbacks) { if (cdc != null) { cdc.onConfirmDialogAnswer(true, _data); } } } }); dialogBuilder.setNegativeButton(getString(R.string.cancel), (dialog, which) -> { dialog.dismiss(); for (ConfirmDialogCallback cdc : _callbacks) { cdc.onConfirmDialogAnswer(false, _data); } }); return dialogBuilder.show(); } public interface ConfirmDialogCallback { void onConfirmDialogAnswer(boolean confirmed, Serializable data); } }<s><start> // Copyright 2004-present Facebook. All Rights Reserved. #include \"SamplingProfilerJniMethod.h\" #include <JavaScriptCore/JSProfilerPrivate.h> #include <jschelpers/JSCHelpers.h> #include <jni.h> #include <string> using namespace facebook::jni; namespace facebook { namespace react { /* static */ jni::local_ref<SamplingProfilerJniMethod::jhybriddata> SamplingProfilerJniMethod::init"}
{"text": "_req_line_done(r) \\ + NGINX_HTTP_READ_REQ_LINE_DONE(r) + +#define ngx_http_probe_read_req_header_done(r, h) \\ + NGINX_HTTP_READ_REQ_HEADER_DONE(r, h) + +#else /* !(NGX_DTRACE) */ + +#define ngx_http_probe_subrequest_cycle(pr, uri, args) +#define ngx_http_probe_subrequest_start(r) +#define ngx_http_probe_subrequest_finalize_writing(r) +#define ngx_http_probe_subrequest_finalize_nonactive(r) +#define ngx_http_probe_subrequest_wake_parent(r) +#define ngx_http_probe_subrequest_done(r) +#define ngx_http_probe_subrequest_post_start(r, rc) +#define ngx_http_probe_subrequest_post_done(r, rc) +#define ngx_http_probe_module_post_config(m) +#define ngx_http_probe_read_body_abort(r, reason) +#define ngx_http_probe_read_body_done(r) +#define ngx_http_probe_read_req_line_done(r) +#define ngx_http_probe_read_req_header_done(r, h) + +#endif /* NGX_DTRACE */ + + +#endif /* _NGX_HTTP_PROBE_H_INCLUDED_ */ diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c index 1bd14e6..92f5a88 100644 --- a/src/http/ngx_http_request.c +++ b/src/http/ngx_http_request.c @@ -8,6 +8,7 @@ #include <ngx_config.h> #include"}
{"text": "Hybrid(jni::alias_ref<jclass>, jlong javaScriptContext) { return makeCxxInstance(javaScriptContext); } /* static */ void SamplingProfilerJniMethod::registerNatives() { registerHybrid( {makeNativeMethod(\"initHybrid\", SamplingProfilerJniMethod::initHybrid), makeNativeMethod(\"poke\", SamplingProfilerJniMethod::poke)}); } SamplingProfilerJniMethod::SamplingProfilerJniMethod(jlong javaScriptContext) { context_ = reinterpret_cast<JSGlobalContextRef>(javaScriptContext); } void SamplingProfilerJniMethod::poke( jni::alias_ref<JSPackagerClientResponder::javaobject> responder) { if (!JSC_JSSamplingProfilerEnabled(context_)) { responder->error(\"The JSSamplingProfiler is disabled. See this \" \"https://fburl.com/u4lw7xeq for some help\"); return; } JSValueRef jsResult = JSC_JSPokeSamplingProfiler(context_); if (JSC_JSValueGetType(context_, jsResult) == kJSTypeNull) { responder->respond(\"started\"); } else { JSStringRef resultStrRef = JSValueToStringCopy(context_, jsResult, nullptr); size_t length = JSStringGetLength(resultStrRef); char buffer[length + 1]; JSStringGetUTF8CString(resultStrRef, buffer, length + 1); JSStringRelease(resultStrRef); responder->respond(buffer); } } } }<s><start> def extractStartlingSurprisesAtEveryStep(item): vol, chp, frag, postfix = extractVolChapterFragmentPostfix(item['title']) if not (chp or vol or frag) or 'preview' in item['title'].lower(): return None if 'bu bu jing xin' in item['tags']: return buildReleaseMessageWithType(item, 'Bu Bu Jing Xin', vol, chp, frag=frag, postfix=postfix) return False<s><start> 'use strict'; var dbm; var type; var seed; /** * We receive the dbmigrate dependency from dbmigrate initially. * This"}
{"text": "<ngx_core.h> #include <ngx_http.h> +#include <ngx_http_probe.h> static void ngx_http_wait_request_handler(ngx_event_t *ev); @@ -1054,7 +1055,6 @@ ngx_http_process_request_line(ngx_event_t *rev) } } - ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r) { @@ -1311,6 +1311,8 @@ ngx_http_process_request_headers(ngx_event_t *rev) return; } + ngx_http_probe_read_req_header_done(r, h); + ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"http header: \\\"%V: %V\\\"\", &h->key, &h->value); @@ -2281,7 +2283,11 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc) } if (r != r->main && r->post_subrequest) { + ngx_http_probe_subrequest_post_start(r, rc); + rc = r->post_subrequest->handler(r, r->post_subrequest->data, rc); + + ngx_http_probe_subrequest_post_done(r, rc); } if (rc == NGX_ERROR @@ -2331,6 +2337,8 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc) if (r->buffered || r->postponed) { + ngx_http_probe_subrequest_finalize_writing(r); + if (ngx_http_set_write_handler(r) != NGX_OK) { ngx_http_terminate_request(r, 0); } @@ -2366,10"}
{"text": "enables us to not have to rely on NODE_PATH. */ exports.setup = function (options, seedLink) { dbm = options.dbmigrate; type = dbm.dataType; seed = seedLink; }; exports.up = function (db) { return Promise.all([ db.runSql('UPDATE office SET name = \\'Office of Brazil and Southern Cone (WHA/BSC)\\' where name=\\'Office of Brail and Southern Cone (WHA/BSC)\\''), db.runSql('UPDATE office SET name = \\'U.S. Embassy La Paz\\' where name=\\'U.S. Embassy LaPaz\\''), ]); }; exports.down = function (db) { return Promise.all([ db.runSql('UPDATE office SET name = \\'Office of Brail and Southern Cone (WHA/BSC)\\' where name=\\'Office of Brazil and Southern Cone (WHA/BSC)\\''), db.runSql('UPDATE office SET name = \\'U.S. Embassy LaPaz\\' where name=\\'U.S. Embassy La Paz\\''), ]); };<s><start> # Copyright 2016 The Chromium Authors. All rights reserved. # Use of this source code is governed by a BSD-style license that can be # found in the LICENSE file. mojom = \"//url/mojo/url.mojom\" public_headers = [ \"//url/gurl.h\" ] traits_headers = [ \"//url/mojo/url_gurl_struct_traits.h\" ] deps = [ \"//url\", ] type_mappings = [ \"url.mojom.Url=GURL\" ]<s><start> require_relative '../../../spec_helper' require 'cgi' describe \"CGI::QueryExtension#from\" do before :each do ENV['REQUEST_METHOD'], @old_request_method = \"GET\", ENV['REQUEST_METHOD'] @cgi = CGI.new end after :each do ENV['REQUEST_METHOD'] = @old_request_method end it \"returns ENV['HTTP_FROM']\" do old_value, ENV['HTTP_FROM'] = ENV['HTTP_FROM'],"}
{"text": "+2374,14 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc) pr->postponed = pr->postponed->next; } + ngx_http_probe_subrequest_done(r); + c->data = pr; } else { + ngx_http_probe_subrequest_finalize_nonactive(r); + ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, \"http finalize non-active request: \\\"%V?%V\\\"\", &r->uri, &r->args); @@ -2381,6 +2393,8 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc) } } + ngx_http_probe_subrequest_wake_parent(r); + if (ngx_http_post_request(pr, NULL) != NGX_OK) { r->main->count++; ngx_http_terminate_request(r, 0); diff --git a/src/http/ngx_http_request_body.c b/src/http/ngx_http_request_body.c index 77e92e3..5b14369 100644 --- a/src/http/ngx_http_request_body.c +++ b/src/http/ngx_http_request_body.c @@ -8,6 +8,7 @@ #include <ngx_config.h> #include <ngx_core.h> #include <ngx_http.h> +#include <ngx_http_probe.h> static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r); @@ -477,6 +478,8 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r) rb->post_handler(r); } + ngx_http_probe_read_body_done("}
{"text": "\"googlebot(at)googlebot.com\" begin @cgi.from.should == \"googlebot(at)googlebot.com\" ensure ENV['HTTP_FROM'] = old_value end end end<s><start> package org.basex.query.func.validate; import org.basex.query.*; import org.basex.query.func.*; import org.basex.query.value.item.*; import org.basex.util.*; /** * Function implementation. * * @author BaseX Team 2005-20, BSD License * @author Christian Gruen */ public final class ValidateXsdProcessor extends StandardFunc { @Override public Item item(final QueryContext qc, final InputInfo ii) { return Str.get(ValidateXsd.IMPL[ValidateXsd.OFFSET + 1]); } }<s><start> <html> <head> <title>Path test</title> <style type=\"text/css\"> .pixel { position: absolute; width: 1px; height: 1px; overflow: hidden; background: #000; } .red { background: red; } .blue { background: blue; } </style> <script language=\"JavaScript\" type=\"text/javascript\"> // Dojo configuration djConfig = { isDebug: true }; </script> <script language=\"JavaScript\" type=\"text/javascript\" src=\"../../dojo.js\"></script> <script language=\"JavaScript\" type=\"text/javascript\"> dojo.require(\"dojo.math.*\"); function drawCurve(curve,steps,className) { if(!className) className = \"pixel\"; if(!steps) steps = 100; this.pixels = new Array(steps) for(var i=0;i<steps;i++) { var pt = curve.getValue(i/steps); this.pixels[i] = document.createElement(\"div\"); this.pixels[i].className = className; this.pixels[i].style.left = pt[0]; this.pixels[i].style.top = pt[1]; document.body.appendChild(this.pixels[i]); } } function init(){ var c = dojo.math.curves; var p = new c.Path(); p.add(new c.Line([10"}
{"text": "r); + return NGX_OK; }<s><start> using Mirror; namespace WeaverTargetRpcTests.TargetRpcValid { class TargetRpcValid : NetworkBehaviour { [TargetRpc] void TargetThatIsTotallyValid(NetworkConnection nc) { } } }<s><start> // Copyright (c) 2013 The Chromium Authors. All rights reserved. // Use of this source code is governed by a BSD-style license that can be // found in the LICENSE file. // // This implements a Clang tool to convert all instances of std::string(\"\") to // std::string(). The latter is more efficient (as std::string doesn't have to // take a copy of an empty string) and generates fewer instructions as well. It // should be run using the tools/clang/scripts/run_tool.py helper. #include <memory> #include \"clang/ASTMatchers/ASTMatchFinder.h\" #include \"clang/ASTMatchers/ASTMatchers.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Frontend/FrontendActions.h\" #include \"clang/Tooling/CommonOptionsParser.h\" #include \"clang/Tooling/Refactoring.h\" #include \"clang/Tooling/Tooling.h\" #include \"llvm/Support/CommandLine.h\" using namespace clang::ast_matchers; using clang::tooling::CommonOptionsParser; using clang::tooling::Replacement; using clang::tooling::Replacements; namespace { // Handles replacements for stack and heap-allocated instances, e.g.: // std::string a(\"\"); // std::string* b = new std::string(\"\"); class ConstructorCallback : public MatchFinder::MatchCallback { public: ConstructorCallback(Replacements* replacements) : replacements_(replacements) {} virtual void run(const MatchFinder::MatchResult& result) override; private: Replacements* const replacements_; }; // Handles replacements for invocations of std::string(\"\") in an initializer // list. class InitializerCallback : public MatchFinder::MatchCallback { public: InitializerCallback(Replacements* replac"}
{"text": ",10], [100,100]), 5); p.add(new c.Line([0,0], [20,0]), 2); p.add(new c.CatmullRom([[0,0], [400,400], [200,200], [500,50]]), 50); p.add(new c.Arc([0,0], [100,100]), 20); p.add(new c.Arc([0,0], [100,100], true), 20); drawCurve(p, 200, \"pixel\"); //drawCurve(new c.Line([0,250], [800,250]), 50, \"pixel red\"); //drawCurve(new c.Line([500,0], [500,600]), 50, \"pixel red\"); //drawCurve(new c.Arc([300,300], [700,200]), 50, \"pixel\"); //drawCurve(new c.Arc([200,200], [100,100], false), 50, \"pixel blue\"); } dojo.addOnLoad(init); </script> </head> <body> </body> </html><s><start> id: dsq-747531936 date: 2010-04-05T22:49:24.0000000-07:00 name: DonSleza4e avatar: https://disqus.com/api/users/avatars/DonSleza4e.jpg message: <p>Awesome<br>Integrated lib with my <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> mvc project ^^</p><s><start> #include <bits/stdc++.h> #define sd(x) scanf(\"%d\",&x) #define sd2(x,y) scanf(\"%d%d\",&x,"}
{"text": "ements) : replacements_(replacements) {} virtual void run(const MatchFinder::MatchResult& result) override; private: Replacements* const replacements_; }; // Handles replacements for invocations of std::string(\"\") in a temporary // context, e.g. FunctionThatTakesString(std::string(\"\")). Note that this // handles implicits construction of std::string as well. class TemporaryCallback : public MatchFinder::MatchCallback { public: TemporaryCallback(Replacements* replacements) : replacements_(replacements) {} virtual void run(const MatchFinder::MatchResult& result) override; private: Replacements* const replacements_; }; class EmptyStringConverter { public: explicit EmptyStringConverter(Replacements* replacements) : constructor_callback_(replacements), initializer_callback_(replacements), temporary_callback_(replacements) {} void SetupMatchers(MatchFinder* match_finder); private: ConstructorCallback constructor_callback_; InitializerCallback initializer_callback_; TemporaryCallback temporary_callback_; }; void EmptyStringConverter::SetupMatchers(MatchFinder* match_finder) { const clang::ast_matchers::StatementMatcher& constructor_call = id( \"call\", cxxConstructExpr( hasDeclaration(cxxMethodDecl(ofClass(hasName(\"std::basic_string\")))), argumentCountIs(2), hasArgument(0, id(\"literal\", stringLiteral())), hasArgument(1, cxxDefaultArgExpr()))); // Note that expr(has()) in the matcher is significant; the Clang AST wraps // calls to the std::string constructor with exprWithCleanups nodes. Without // the expr(has()) matcher, the first and last rules would not match anything! match_finder->addMatcher(varDecl(forEach(expr(has(constructor_call)))), &constructor_callback_); match_finder->addMatcher(cxxNewExpr(has(constructor_call)), &constructor_callback_); // The implicitly generated constructor for temporary could be wrapped by // implicitCastExpr, so ignoringParenImpCasts is needed. match_finder->addMatcher( cxxBindTemporaryExpr"}
{"text": "&y) #define sd3(x,y,z) scanf(\"%d%d%d\",&x,&y,&z) #define fi first #define se second #define pb(x) push_back(x) #define mp(x,y) make_pair(x,y) #define LET(x, a) __typeof(a) x(a) #define foreach(it, v) for(LET(it, v.begin()); it != v.end(); it++) #define _ ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); #define __ freopen(\"input.txt\",\"r\",stdin);freopen(\"output.txt\",\"w\",stdout); #define func __FUNCTION__ #define line __LINE__ using namespace std; template<typename S, typename T> ostream& operator<<(ostream& out, pair<S, T> const& p){out<<'('<<p.fi<<\", \"<<p.se<<')'; return out;} template<typename T> ostream& operator<<(ostream& out, vector<T> const & v){ int l = v.size(); for(int i = 0; i < l-1; i++) out<<v[i]<<' '; if(l>0) out<<v[l-1]; return out;} void tr(){cout << endl;} template<typename S, typename ... Strings> void tr(S x, const Strings&... rest){cout<<x<<' ';tr(rest...);} const int N = 100100; int n, p; int l[N], r[N]; int main(){ sd2(n,p); for(int i = 0; i < n; i++){ sd2(l[i], r[i]); } l[n] = l[0]; r[n] = r[0]; long double res = 0; for(int i = 1; i <= n; i++){ long long v1 = (r[i]/p) - ((l[i]-1)/p); long long v2 = (r[i-1]/p) - ((l[i-1]-1)/p); long long l1 = r[i]-"}
{"text": "(ignoringParenImpCasts(forEach(constructor_call))), &temporary_callback_); // Note that forEachConstructorInitializer is needed. The std::string // constructor is wrapped by exprWithCleanups and cxxCtorInitializer. // forEach() would not work. match_finder->addMatcher(cxxConstructorDecl(forEachConstructorInitializer( withInitializer(expr(has(constructor_call))))), &initializer_callback_); } void ConstructorCallback::run(const MatchFinder::MatchResult& result) { const clang::StringLiteral* literal = result.Nodes.getNodeAs<clang::StringLiteral>(\"literal\"); if (literal->getLength() > 0) return; const clang::CXXConstructExpr* call = result.Nodes.getNodeAs<clang::CXXConstructExpr>(\"call\"); clang::CharSourceRange range = clang::CharSourceRange::getTokenRange(call->getParenOrBraceRange()); auto err = replacements_->add(Replacement(*result.SourceManager, range, \"\")); assert(!err); } void InitializerCallback::run(const MatchFinder::MatchResult& result) { const clang::StringLiteral* literal = result.Nodes.getNodeAs<clang::StringLiteral>(\"literal\"); if (literal->getLength() > 0) return; const clang::CXXConstructExpr* call = result.Nodes.getNodeAs<clang::CXXConstructExpr>(\"call\"); auto err = replacements_->add(Replacement(*result.SourceManager, call, \"\")); assert(!err); } void TemporaryCallback::run(const MatchFinder::MatchResult& result) { const clang::StringLiteral* literal = result.Nodes.getNodeAs<clang::StringLiteral>(\"literal\"); if (literal->getLength() > 0) return; const clang::CXXConstructExpr* call = result.Nodes.getNodeAs<clang::CXXConstructExpr>(\"call\"); // Differentiate between explicit and implicit calls to std::string's // constructor. An implicitly generated constructor won't have a valid // source range for the parenthesis. We do this because the"}
{"text": "l[i]+1; long long l2 = r[i-1]-l[i-1]+1; long long t = (l1-v1)*(l2-v2); long double p = (long double) t / (long double) (l1*l2); p = 1.0f-p; res += p*2000; } printf(\"%.9lf\\n\", (double)res); return 0; }<s><start> // RUN: %clang_cc1 -emit-llvm -triple i386-apple-macosx10.7.2 < %s | FileCheck %s // The preferred alignment for a long long on x86-32 is 8; make sure the // alloca for x uses that alignment. int test (long long x) { return (int)x; } // CHECK-LABEL: define i32 @test // CHECK: alloca i64, align 8 // Make sure we honor the aligned attribute. struct X { int x,y,z,a; }; int test2(struct X x __attribute((aligned(16)))) { return x.z; } // CHECK-LABEL: define i32 @test2 // CHECK: alloca %struct._Z1X, align 16<s><start> export const environment = { production: true };<s><start> import { Component, Inject, Input } from '@angular/core'; import { MediaObserver } from '@angular/flex-layout'; import { Observable } from 'rxjs'; import { map, startWith } from 'rxjs/operators'; import { API_BASE_URL } from '../../app.tokens'; import { Product } from '../../shared/services'; @Component({ selector: 'nga-product-suggestion', styleUrls: [ './product-suggestion.component.scss' ], templateUrl: './product-suggestion.component.html' }) export class ProductSuggestionComponent { @Input() products: Product[]; readonly columns$: Observable<number>; readonly breakpointsToColumnsNumber = new Map([ [ 'xs', 2 ], [ 'sm', 3 ], [ 'md', 5 ], [ 'lg', 2 ], [ 'xl', 3 ], ]); constructor( @Inject(API_BASE_URL) private"}
{"text": "matched expression // for |call| in the explicit case doesn't include the closing parenthesis. clang::SourceRange range = call->getParenOrBraceRange(); if (range.isValid()) { auto err = replacements_->add(Replacement(*result.SourceManager, literal, \"\")); assert(!err); } else { auto err = replacements_->add( Replacement(*result.SourceManager, call, literal->isWide() ? \"std::wstring()\" : \"std::string()\")); assert(!err); } } } // namespace static llvm::cl::extrahelp common_help(CommonOptionsParser::HelpMessage); int main(int argc, const char* argv[]) { llvm::cl::OptionCategory category(\"EmptyString Tool\"); CommonOptionsParser options(argc, argv, category); clang::tooling::ClangTool tool(options.getCompilations(), options.getSourcePathList()); Replacements replacements; EmptyStringConverter converter(&replacements); MatchFinder match_finder; converter.SetupMatchers(&match_finder); std::unique_ptr<clang::tooling::FrontendActionFactory> frontend_factory = clang::tooling::newFrontendActionFactory(&match_finder); int result = tool.run(frontend_factory.get()); if (result != 0) return result; if (replacements.empty()) return 0; // Each replacement line should have the following format: // r:<file path>:<offset>:<length>:<replacement text> // Only the <replacement text> field can contain embedded \":\" characters. // TODO(dcheng): Use a more clever serialization. Ideally we'd use the YAML // serialization and then use clang-apply-replacements, but that would require // copying and pasting a larger amount of boilerplate for all Chrome clang // tools. llvm::outs() << \"==== BEGIN EDITS ====\\n\"; for (const auto& r : replacements) { llvm::outs() << \"r:::\" << r.getFilePath() << \":::\" << r.getOffset() << \":::\" << r.getLength() << \":::\" << r.getReplacementText() << \"\\n\"; } llvm::outs()"}
{"text": "readonly baseUrl: string, private readonly media: MediaObserver ) { // If the initial screen size is xs ObservableMedia doesn't emit an event // In the older versions of flex-layout we used ObservableMedia, which is deprecated. // Use MediaObserver instead this.columns$ = this.media.media$ .pipe( map(mc => <number>this.breakpointsToColumnsNumber.get(mc.mqAlias)), startWith(3) ); } urlFor(product: Product): string { return `${this.baseUrl}/${product.imageUrl}`; } }<s><start> <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" xmlns:android=\"http://schemas.android.com/apk/res/android\" > <Button android:id=\"@+id/btn_crash_restart\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"\u91cd\u542fApp\" android:layout_alignParentTop=\"true\" /> <TextView android:id=\"@+id/tv_crash_info\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:singleLine=\"false\" android:ellipsize=\"none\" android:gravity=\"left\" android:inputType=\"textMultiLine\" android:layout_below=\"@id/btn_crash_restart\" /> </RelativeLayout><s><start> SET UTF-8 LANG tr<s><start> f := function() local l; l := 0 * [1..6]; l[[1..3]] := 1; end; f(); Where(); WhereWithVars(); quit; f:=function() if true = 1/0 then return 1; fi; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() local x; if x then return 1; fi; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() if 1 then return 1; fi; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() if 1 < 0 then return 1; elif 1 then return 2; fi; return 3; end;; f(); Where(); WhereWithVars();"}
{"text": "<< \"==== END EDITS ====\\n\"; return 0; }<s><start> using NHapi.Base.Parser; using NHapi.Base; using NHapi.Base.Log; using System; using System.Collections.Generic; using NHapi.Model.V26.Segment; using NHapi.Model.V26.Datatype; using NHapi.Base.Model; namespace NHapi.Model.V26.Group { ///<summary> ///Represents the RRI_I12_AUTHORIZATION_CONTACT Group. A Group is an ordered collection of message /// segments that can repeat together or be optionally in/excluded together. /// This Group contains the following elements: ///<ol> ///<li>0: AUT (Authorization Information) </li> ///<li>1: CTD (Contact Data) optional </li> ///</ol> ///</summary> [Serializable] public class RRI_I12_AUTHORIZATION_CONTACT : AbstractGroup { ///<summary> /// Creates a new RRI_I12_AUTHORIZATION_CONTACT Group. ///</summary> public RRI_I12_AUTHORIZATION_CONTACT(IGroup parent, IModelClassFactory factory) : base(parent, factory){ try { this.add(typeof(AUT), true, false); this.add(typeof(CTD), false, false); } catch(HL7Exception e) { HapiLogFactory.GetHapiLog(GetType()).Error(\"Unexpected error creating RRI_I12_AUTHORIZATION_CONTACT - this is probably a bug in the source code generator.\", e); } } ///<summary> /// Returns AUT (Authorization Information) - creates it if necessary ///</summary> public AUT AUT { get{ AUT ret = null; try { ret = (AUT)this.GetStructure(\"AUT\"); } catch(HL7Exception e) { HapiLogFactory.GetHapiLog(GetType()).Error(\"Unexpected error accessing data - this is probably a bug in the source code generator.\", e); throw new System.Exception(\"An unexpected error ocurred\",e); } return ret; } } ///<summary> /// Returns CTD (Contact Data) - creates it if necessary"}
{"text": "quit; f:=function() while 1 do return 1; od; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() local i; for i in 1 do return 1; od; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() local i; for i in true do return 1; od; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function(x) local i,j; for i in true do return 1; od; return 2; end;; f([1,2,3]); Where(); WhereWithVars(); quit; f:=function(x) local i,j; Unbind(x); for i in true do return 1; od; return 2; end;; f([1,2,3]); Where(); WhereWithVars(); quit; f:=function(x) local i,j; Unbind(x); j := 4; for i in true do return 1; od; return 2; end;; f([1,2,3]); Where(); WhereWithVars(); quit; f:=function() local x; repeat x:=1; until 1; return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() local x; Assert(0, 1); return 2; end;; f(); Where(); WhereWithVars(); quit; f:=function() local x; Assert(0, 1, \"hello\"); return 2; end;; f(); Where(); WhereWithVars(); quit; # Verify issue #2656 is fixed InstallMethod( \\[\\,\\], [ IsMatrixObj, IsPosInt, IsPosInt ], { m, row, col } -> ELM_LIST( m, row, col ) ); l := [[1]];; f := {} -> l[2,1];; f(); Where(); WhereWithVars(); quit; # verify issue #1373 is fixed InstallMethod( Matrix, [IsFilter, IsSemiring, IsMatrixObj], {a,b,c} -> fail );<s><start> package org.jetbrains.dokka.base.transformers.documentables import org.jetbrains.dokka.model.* import org.jetbrains.dokka.plugability."}
{"text": "///</summary> public CTD CTD { get{ CTD ret = null; try { ret = (CTD)this.GetStructure(\"CTD\"); } catch(HL7Exception e) { HapiLogFactory.GetHapiLog(GetType()).Error(\"Unexpected error accessing data - this is probably a bug in the source code generator.\", e); throw new System.Exception(\"An unexpected error ocurred\",e); } return ret; } } } }<s><start> #!/bin/bash if [ -z \"$1\" ]; then echo \"This script must be called with an argument\" >&2 exit 1 fi /usr/local/bin/mine $(script/find_spec_or_impl.rb $1)<s><start> /* This repository is no longer actively maintained. To find all solutions to this problem (and practice coding more problems) at: ~~~~~~~~~~~~~~~~~~~~~~~~~ https://backtobackswe.com ~~~~~~~~~~~~~~~~~~~~~~~~~ */ public class Solution { public static void main(String args[]) { /* Here you are given the adjacency list, but even if you were given the raw edges and vertices (remember: G = (V, E)), you'd still be able to build the adjacency list in O(|E|) time. Just loop over the edges and build what you see below. */ Map<Integer, List<Integer>> originalNodeToAdjacents = new HashMap<>(); originalNodeToAdjacents.put(0, Arrays.asList(1)); originalNodeToAdjacents.put(1, Arrays.asList(2)); originalNodeToAdjacents.put(2, Arrays.asList(3, 4)); originalNodeToAdjacents.put(3, Arrays.asList(0)); originalNodeToAdjacents.put(4, Arrays.asList(2)); /* The graph above: 0 ---> 1 ---> 2 <---> 4 ^ / \\ / \\ / \\ \u2304 3 */ /* If we reverse each edge: 0 <--- 1 <--- 2 <---> 4 \\ ^ \\ / \\ / \u2304 / 3 */ System.out.println(isStronglyConnected(originalNodeToAdjacents)); } private static boolean isStronglyConnected(Map<Integer,"}
{"text": "DokkaContext import org.jetbrains.dokka.transformers.documentation.PreMergeDocumentableTransformer import org.jetbrains.dokka.transformers.documentation.perPackageOptions import org.jetbrains.dokka.transformers.documentation.source import org.jetbrains.dokka.transformers.documentation.sourceSet import java.io.File class SuppressedDocumentableFilterTransformer(val context: DokkaContext) : PreMergeDocumentableTransformer { override fun invoke(modules: List<DModule>): List<DModule> { return modules.mapNotNull(::filterModule) } private fun filterModule(module: DModule): DModule? { val packages = module.packages.mapNotNull { pkg -> filterPackage(pkg) } return when { packages == module.packages -> module packages.isEmpty() -> null else -> module.copy(packages = packages) } } private fun filterPackage(pkg: DPackage): DPackage? { val options = perPackageOptions(pkg) if (options?.suppress == true) { return null } val filteredChildren = pkg.children.filterNot(::isSuppressed) return when { filteredChildren == pkg.children -> pkg filteredChildren.isEmpty() -> null else -> pkg.copy( functions = filteredChildren.filterIsInstance<DFunction>(), classlikes = filteredChildren.filterIsInstance<DClasslike>(), typealiases = filteredChildren.filterIsInstance<DTypeAlias>(), properties = filteredChildren.filterIsInstance<DProperty>() ) } } private fun isSuppressed(documentable: Documentable): Boolean { if (documentable !is WithSources) return false val sourceFile = File(source(documentable).path).absoluteFile return sourceSet(documentable).suppressedFiles.any { suppressedFile -> sourceFile.startsWith(suppressedFile.absoluteFile) } } }<s><start> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Workspace version = \"1.0\"> <FileRef location = \"group:Runner.xcodeproj\"> </FileRef> </Workspace><s><start> /* * linux/include/asm-arm/proc-armv/processor.h * * Copyright (C) 1996-1999 Russell King. * * This program"}
{"text": "List<Integer>> originalNodeToAdjacents) { boolean allNodesReached = allNodesReachedViaBFS(originalNodeToAdjacents); if (!allNodesReached) { return false; } Map<Integer, List<Integer>> reversedNodeToAdjacents = reverseGraph(originalNodeToAdjacents); boolean allNodesReachedWithReverseGraph = allNodesReachedViaBFS(reversedNodeToAdjacents); return allNodesReachedWithReverseGraph; } private static boolean allNodesReachedViaBFS(Map<Integer, List<Integer>> originalNodeToAdjacents) { Set<Integer> visited = new HashSet<>(); Queue<Integer> queue = new LinkedList<>(); queue.add(0); visited.add(0); while (!queue.isEmpty()) { int node = queue.poll(); List<Integer> adjacents = originalNodeToAdjacents.get(node); if (adjacents != null) { for (int adjacent: adjacents) { if (!visited.contains(adjacent)) { visited.add(adjacent); queue.add(adjacent); } } } } return visited.size() == originalNodeToAdjacents.size(); } private static Map<Integer, List<Integer>> reverseGraph(Map<Integer, List<Integer>> originalNodeToAdjacents) { Map<Integer, List<Integer>> reversedNodeToAdjacents = new HashMap<>(); for (Map.Entry<Integer, List<Integer>> entry: originalNodeToAdjacents.entrySet()) { int nodeValue = entry.getKey(); List<Integer> adjacents = entry.getValue(); // Reverse each edge for (int adjacent: adjacents) { List<Integer> reversedAdjacents; if (!reversedNodeToAdjacents.containsKey(adjacent)) { reversedAdjacents = new ArrayList<>(); } else { reversedAdjacents = reversedNodeToAdjacents.get(adjacent); } // Reverse edge, before node went to adjacent, now adjacent maps to the node reversedAdjacents.add(nodeValue); reversedNodeToAdjacents.put(adjacent, reversedAdjacents); } } return reversedNodeTo"}
{"text": "is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 as * published by the Free Software Foundation. * * Changelog: * 20-09-1996 RMK Created * 26-09-1996 RMK Added 'EXTRA_THREAD_STRUCT*' * 28-09-1996 RMK Moved start_thread into the processor dependencies * 09-09-1998 PJB Delete redundant `wp_works_ok' * 30-05-1999 PJB Save sl across context switches * 31-07-1999 RMK Added 'domain' stuff */ #ifndef __ASM_PROC_PROCESSOR_H #define __ASM_PROC_PROCESSOR_H #include <asm/proc/domain.h> #define KERNEL_STACK_SIZE PAGE_SIZE struct context_save_struct { unsigned long cpsr; unsigned long r4; unsigned long r5; unsigned long r6; unsigned long r7; unsigned long r8; unsigned long r9; unsigned long sl; unsigned long fp; unsigned long pc; }; #define INIT_CSS (struct context_save_struct){ SVC_MODE, 0, 0, 0, 0, 0, 0, 0, 0, 0 } #define EXTRA_THREAD_STRUCT \\ unsigned int domain; #define EXTRA_THREAD_STRUCT_INIT \\ domain: domain_val(DOMAIN_USER, DOMAIN_CLIENT) | \\ domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \\ domain_val(DOMAIN_IO, DOMAIN_CLIENT) #define start_thread(regs,pc,sp) \\ ({ \\ unsigned long *stack = (unsigned long *)sp; \\ set_fs(USER_DS); \\ memzero(regs->uregs, sizeof(regs->uregs)); \\ if (current->personality & ADDR_LIMIT_32BIT) \\ regs->ARM_cpsr = USR_MODE; \\ else"}
{"text": "Adjacents; } }<s><start> /* * QEMU Common PCI Host bridge configuration data space access routines. * * Copyright (c) 2006 Fabrice Bellard * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /* Worker routines for a PCI host controller that uses an {address,data} register pair to access PCI configuration space. */ #ifndef PCI_HOST_H #define PCI_HOST_H #include \"hw/sysbus.h\" #define TYPE_PCI_HOST_BRIDGE \"pci-host-bridge\" #define PCI_HOST_BRIDGE(obj) \\ OBJECT_CHECK(PCIHostState, (obj), TYPE_PCI_HOST_BRIDGE) #define PCI_HOST_BRIDGE_CLASS(klass) \\ OBJECT_CLASS_CHECK("}
{"text": "\\ regs->ARM_cpsr = USR26_MODE; \\ regs->ARM_pc = pc; /* pc */ \\ regs->ARM_sp = sp; /* sp */ \\ regs->ARM_r2 = stack[2]; /* r2 (envp) */ \\ regs->ARM_r1 = stack[1]; /* r1 (argv) */ \\ regs->ARM_r0 = stack[0]; /* r0 (argc) */ \\ }) #define KSTK_EIP(tsk) (((unsigned long *)(4096+(unsigned long)(tsk)))[1019]) #define KSTK_ESP(tsk) (((unsigned long *)(4096+(unsigned long)(tsk)))[1017]) /* Allocation and freeing of basic task resources. */ /* * NOTE! The task struct and the stack go together */ #define ll_alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1)) #define ll_free_task_struct(p) free_pages((unsigned long)(p),1) #endif<s><start> if (global.GENTLY) require = GENTLY.hijack(require); var crypto = require('crypto'); var fs = require('fs'); var util = require('util'), path = require('path'), File = require('./file'), MultipartParser = require('./multipart_parser').MultipartParser, QuerystringParser = require('./querystring_parser').QuerystringParser, OctetParser = require('./octet_parser').OctetParser, JSONParser = require('./json_parser').JSONParser, StringDecoder = require('string_decoder').StringDecoder, EventEmitter = require('events').EventEmitter, Stream = require('stream').Stream, os = require('os'); function IncomingForm(opts) { if (!(this instanceof IncomingForm)) return new IncomingForm(opts); EventEmitter.call(this); opts=opts||{}; this.error = null; this.ended = false; this.maxFields = opts.maxFields || 1000; this.maxFieldsSize = opts.maxFieldsSize || 2 *"}
{"text": "PCIHostBridgeClass, (klass), TYPE_PCI_HOST_BRIDGE) #define PCI_HOST_BRIDGE_GET_CLASS(obj) \\ OBJECT_GET_CLASS(PCIHostBridgeClass, (obj), TYPE_PCI_HOST_BRIDGE) struct PCIHostState { SysBusDevice busdev; MemoryRegion conf_mem; MemoryRegion data_mem; MemoryRegion mmcfg; uint32_t config_reg; PCIBus *bus; QLIST_ENTRY(PCIHostState) next; }; typedef struct PCIHostBridgeClass { SysBusDeviceClass parent_class; const char *(*root_bus_path)(PCIHostState *, PCIBus *); } PCIHostBridgeClass; /* common internal helpers for PCI/PCIe hosts, cut off overflows */ void pci_host_config_write_common(PCIDevice *pci_dev, uint32_t addr, uint32_t limit, uint32_t val, uint32_t len); uint32_t pci_host_config_read_common(PCIDevice *pci_dev, uint32_t addr, uint32_t limit, uint32_t len); void pci_data_write(PCIBus *s, uint32_t addr, uint32_t val, unsigned len); uint32_t pci_data_read(PCIBus *s, uint32_t addr, unsigned len); extern const MemoryRegionOps pci_host_conf_le_ops; extern const MemoryRegionOps pci_host_conf_be_ops; extern const MemoryRegionOps pci_host_data_le_ops; extern const MemoryRegionOps pci_host_data_be_ops; #endif /* PCI_HOST_H */<s><start> /** * Copyright (c) 2016-present, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * LICENSE file in the root directory of this source tree. An additional grant * of patent rights can be found in the PATENTS file in the same"}
{"text": "1024 * 1024; this.keepExtensions = opts.keepExtensions || false; this.uploadDir = opts.uploadDir || os.tmpDir(); this.encoding = opts.encoding || 'utf-8'; this.headers = null; this.type = null; this.hash = opts.hash || false; this.multiples = opts.multiples || false; this.bytesReceived = null; this.bytesExpected = null; this._parser = null; this._flushing = 0; this._fieldsSize = 0; this.openedFiles = []; return this; } util.inherits(IncomingForm, EventEmitter); exports.IncomingForm = IncomingForm; IncomingForm.prototype.parse = function(req, cb) { this.pause = function() { try { req.pause(); } catch (err) { // the stream was destroyed if (!this.ended) { // before it was completed, crash & burn this._error(err); } return false; } return true; }; this.resume = function() { try { req.resume(); } catch (err) { // the stream was destroyed if (!this.ended) { // before it was completed, crash & burn this._error(err); } return false; } return true; }; // Setup callback first, so we don't miss anything from data events emitted // immediately. if (cb) { var fields = {}, files = {}; this .on('field', function(name, value) { fields[name] = value; }) .on('file', function(name, file) { if (this.multiples) { if (files[name]) { if (!Array.isArray(files[name])) { files[name] = [files[name]]; } files[name].push(file); } else { files[name] = file; } } else { files[name] = file; } }) .on('error', function(err) { cb(err, fields, files); }) .on('end', function() { cb(null, fields, files); }); } // Parse headers and setup the parser, ready to start listening for data. this.writeHeaders(req.headers); // Start listening for data. var self = this; req .on('error', function(err) { self._error(err);"}
{"text": "directory. */ #import <XCTest/XCTest.h> #import <IGListKit/IGListKit.h> #import \"IGListDebugger.h\" #import \"IGListAdapterUpdaterInternal.h\" #import \"IGListTestAdapterDataSource.h\" #import \"IGListMoveIndexInternal.h\" #import \"IGListMoveIndexPathInternal.h\" @interface IGListDebuggerTests : XCTestCase @end @implementation IGListDebuggerTests - (void)test_whenSearchingAdapterInstances_thatCorrectCountReturned { UIViewController *controller = [UIViewController new]; UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:[UICollectionViewFlowLayout new]]; IGListAdapterUpdater *updater = [IGListAdapterUpdater new]; NSIndexPath *path = [NSIndexPath indexPathForItem:0 inSection:0]; updater.applyingUpdateData = [[IGListBatchUpdateData alloc] initWithInsertSections:[NSIndexSet indexSetWithIndex:1] deleteSections:[NSIndexSet indexSetWithIndex:2] moveSections:[NSSet setWithObject:[[IGListMoveIndex alloc] initWithFrom:3 to:4]] insertIndexPaths:@[path] deleteIndexPaths:@[path] moveIndexPaths:@[[[IGListMoveIndexPath alloc] initWithFrom:path to:path]]]; IGListTestAdapterDataSource *dataSource = [IGListTestAdapterDataSource new]; dataSource.objects = @[@1, @2, @3]; IGListAdapter *adapter1 = [[IGListAdapter alloc] initWithUpdater:[IGListAdapterUpdater new] viewController:nil workingRangeSize:0]; adapter1.collectionView = collectionView; adapter1.dataSource = dataSource; IGListAdapter *adapter2 = [[IGListAdapter alloc] initWithUpdater:[IGListAdapterUpdater new] viewController:controller workingRangeSize:2]; adapter2.collectionView = collectionView; IGListAdapter *adapter3 = [[IGListAdapter alloc] initWithUpdater:[IGListAdapterUpdater new] viewController:controller workingRangeSize:2]; adapter3.collectionView = collectionView; NSArray *descriptions = [IGListDebugger adapterDescriptions]; XCTAssertEqual("}
{"text": "}) .on('aborted', function() { self.emit('aborted'); self._error(new Error('Request aborted')); }) .on('data', function(buffer) { self.write(buffer); }) .on('end', function() { if (self.error) { return; } var err = self._parser.end(); if (err) { self._error(err); } }); return this; }; IncomingForm.prototype.writeHeaders = function(headers) { this.headers = headers; this._parseContentLength(); this._parseContentType(); }; IncomingForm.prototype.write = function(buffer) { if (this.error) { return; } if (!this._parser) { this._error(new Error('uninitialized parser')); return; } this.bytesReceived += buffer.length; this.emit('progress', this.bytesReceived, this.bytesExpected); var bytesParsed = this._parser.write(buffer); if (bytesParsed !== buffer.length) { this._error(new Error('parser error, '+bytesParsed+' of '+buffer.length+' bytes parsed')); } return bytesParsed; }; IncomingForm.prototype.pause = function() { // this does nothing, unless overwritten in IncomingForm.parse return false; }; IncomingForm.prototype.resume = function() { // this does nothing, unless overwritten in IncomingForm.parse return false; }; IncomingForm.prototype.onPart = function(part) { // this method can be overwritten by the user this.handlePart(part); }; IncomingForm.prototype.handlePart = function(part) { var self = this; if (part.filename === undefined) { var value = '' , decoder = new StringDecoder(this.encoding); part.on('data', function(buffer) { self._fieldsSize += buffer.length; if (self._fieldsSize > self.maxFieldsSize) { self._error(new Error('maxFieldsSize exceeded, received '+self._fieldsSize+' bytes of field data')); return; } value += decoder.write(buffer); }); part.on('end', function() { self.emit('field', part.name, value); }); return; } this._flushing++; var file = new File({ path: this._uploadPath(part.filename),"}
{"text": "descriptions.count, 4); } @end<s><start> <?xml version=\"1.0\"?> <ZopeData> <record id=\"1\" aka=\"AAAAAAAAAAE=\"> <pickle> <global name=\"ProxyField\" module=\"Products.ERP5Form.ProxyField\"/> </pickle> <pickle> <dictionary> <item> <key> <string>id</string> </key> <value> <string>my_text_area_field</string> </value> </item> <item> <key> <string>message_values</string> </key> <value> <dictionary> <item> <key> <string>external_validator_failed</string> </key> <value> <string>The input failed the external validator.</string> </value> </item> </dictionary> </value> </item> <item> <key> <string>overrides</string> </key> <value> <dictionary> <item> <key> <string>field_id</string> </key> <value> <string></string> </value> </item> <item> <key> <string>form_id</string> </key> <value> <string></string> </value> </item> <item> <key> <string>target</string> </key> <value> <string></string> </value> </item> </dictionary> </value> </item> <item> <key> <string>tales</string> </key> <value> <dictionary> <item> <key> <string>field_id</string> </key> <value> <string></string> </value> </item> <item> <key> <string>form_id</string> </key> <value> <string></string> </value> </item> <item> <key> <string>target</string> </key> <value> <string></string> </value> </item> </dictionary> </value> </item> <item> <key> <string>values</string> </key> <value> <dictionary> <item> <key> <string>field_id</string> </key> <value> <string>my_text_area_field</string> </value> </item> <item> <key> <string"}
{"text": "name: part.filename, type: part.mime, hash: self.hash }); this.emit('fileBegin', part.name, file); file.open(); this.openedFiles.push(file); part.on('data', function(buffer) { if (buffer.length == 0) { return; } self.pause(); file.write(buffer, function() { self.resume(); }); }); part.on('end', function() { file.end(function() { self._flushing--; self.emit('file', part.name, file); self._maybeEnd(); }); }); }; function dummyParser(self) { return { end: function () { self.ended = true; self._maybeEnd(); return null; } }; } IncomingForm.prototype._parseContentType = function() { if (this.bytesExpected === 0) { this._parser = dummyParser(this); return; } if (!this.headers['content-type']) { this._error(new Error('bad content-type header, no content-type')); return; } if (this.headers['content-type'].match(/octet-stream/i)) { this._initOctetStream(); return; } if (this.headers['content-type'].match(/urlencoded/i)) { this._initUrlencoded(); return; } if (this.headers['content-type'].match(/multipart/i)) { var m = this.headers['content-type'].match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i); if (m) { this._initMultipart(m[1] || m[2]); } else { this._error(new Error('bad content-type header, no multipart boundary')); } return; } if (this.headers['content-type'].match(/json/i)) { this._initJSONencoded(); return; } this._error(new Error('bad content-type header, unknown content-type: '+this.headers['content-type'])); }; IncomingForm.prototype._error = function(err) { if (this.error || this.ended) { return; } this.error = err; this.emit('error', err); if (Array.isArray(this.openedFiles)) { this.openedFiles.forEach(function(file) { file._write"}
{"text": ">form_id</string> </key> <value> <string>Base_viewFieldLibrary</string> </value> </item> <item> <key> <string>target</string> </key> <value> <string>Click to edit the target</string> </value> </item> </dictionary> </value> </item> </dictionary> </pickle> </record> </ZopeData><s><start> /* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ drop dataverse test if exists; create dataverse test; use test; create type test.MyRecord as { id : bigint, point : point, kwds : string }; create external dataset MyData(MyRecord) using localfs((`path`=`asterix_nc1://data/spatial/spatialData.json`),(`format`=`adm`));<s><start> <!-- ~ Copyright 2019. Google LLC ~ ~ Licensed under the Apache License, Version 2.0 (the \"License\"); ~ you may not use this file except in compliance with the License. ~ You may obtain a copy of the License at ~ ~ https://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, software ~ distributed under the License is distributed on an \"AS IS\" BASIS, ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ~ See the License for the specific language gover"}
{"text": "Stream.destroy(); setTimeout(fs.unlink, 0, file.path, function(error) { }); }); } }; IncomingForm.prototype._parseContentLength = function() { this.bytesReceived = 0; if (this.headers['content-length']) { this.bytesExpected = parseInt(this.headers['content-length'], 10); } else if (this.headers['transfer-encoding'] === undefined) { this.bytesExpected = 0; } if (this.bytesExpected !== null) { this.emit('progress', this.bytesReceived, this.bytesExpected); } }; IncomingForm.prototype._newParser = function() { return new MultipartParser(); }; IncomingForm.prototype._initMultipart = function(boundary) { this.type = 'multipart'; var parser = new MultipartParser(), self = this, headerField, headerValue, part; parser.initWithBoundary(boundary); parser.onPartBegin = function() { part = new Stream(); part.readable = true; part.headers = {}; part.name = null; part.filename = null; part.mime = null; part.transferEncoding = 'binary'; part.transferBuffer = ''; headerField = ''; headerValue = ''; }; parser.onHeaderField = function(b, start, end) { headerField += b.toString(self.encoding, start, end); }; parser.onHeaderValue = function(b, start, end) { headerValue += b.toString(self.encoding, start, end); }; parser.onHeaderEnd = function() { headerField = headerField.toLowerCase(); part.headers[headerField] = headerValue; var m = headerValue.match(/\\bname=\"([^\"]+)\"/i); if (headerField == 'content-disposition') { if (m) { part.name = m[1]; } part.filename = self._fileName(headerValue); } else if (headerField == 'content-type') { part.mime = headerValue; } else if (headerField == 'content-transfer-encoding') { part.transferEncoding = headerValue.toLowerCase(); } headerField = ''; headerValue = ''; }; parser.onHeadersEnd = function() { switch(part.transferEncoding){ case 'binary': case '"}
{"text": "ning permissions and ~ limitations under the License. --> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/bg_blue\" android:orientation=\"vertical\" android:padding=\"20dp\" tools:context=\"com.google.android.apps.santatracker.dasherdancer.CharacterActivity\" > <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:orientation=\"horizontal\" > <View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:visibility=\"invisible\" /> <ImageButton android:id=\"@+id/btn_character_santa\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:adjustViewBounds=\"true\" android:background=\"@drawable/dasher_ripple\" android:onClick=\"onCharacterClick\" android:scaleType=\"fitCenter\" android:layout_gravity=\"bottom\" android:src=\"@drawable/santa\" /> <View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:visibility=\"invisible\" /> </LinearLayout> <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:orientation=\"horizontal\" > <ImageButton android:id=\"@+id/btn_character_elf\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:adjustViewBounds=\"true\" android:background=\"@drawable/dasher_ripple\" android:onClick=\"onCharacterClick\" android:scaleType=\"fitCenter\" android:layout_gravity=\"center\" android:src=\"@drawable/elf\" /> <View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:visibility=\"invisible\" /> <ImageButton android:id=\"@+id"}
{"text": "7bit': case '8bit': parser.onPartData = function(b, start, end) { part.emit('data', b.slice(start, end)); }; parser.onPartEnd = function() { part.emit('end'); }; break; case 'base64': parser.onPartData = function(b, start, end) { part.transferBuffer += b.slice(start, end).toString('ascii'); /* four bytes (chars) in base64 converts to three bytes in binary encoding. So we should always work with a number of bytes that can be divided by 4, it will result in a number of buytes that can be divided vy 3. */ var offset = parseInt(part.transferBuffer.length / 4, 10) * 4; part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64')); part.transferBuffer = part.transferBuffer.substring(offset); }; parser.onPartEnd = function() { part.emit('data', new Buffer(part.transferBuffer, 'base64')); part.emit('end'); }; break; default: return self._error(new Error('unknown transfer-encoding')); } self.onPart(part); }; parser.onEnd = function() { self.ended = true; self._maybeEnd(); }; this._parser = parser; }; IncomingForm.prototype._fileName = function(headerValue) { var m = headerValue.match(/\\bfilename=\"(.*?)\"($|; )/i); if (!m) return; var filename = m[1].substr(m[1].lastIndexOf('\\\\') + 1); filename = filename.replace(/%22/g, '\"'); filename = filename.replace(/&#([\\d]{4});/g, function(m, code) { return String.fromCharCode(code); }); return filename; }; IncomingForm.prototype._initUrlencoded = function() { this.type = 'urlencoded'; var parser = new QuerystringParser(this.maxFields) , self = this; parser.onField = function(key, val) { self.emit('field', key, val); }; parser.onEnd = function() { self.ended = true; self._maybeEnd(); }; this._parser = parser"}
{"text": "/btn_character_reindeer\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:adjustViewBounds=\"true\" android:background=\"@drawable/dasher_ripple\" android:onClick=\"onCharacterClick\" android:scaleType=\"fitCenter\" android:layout_gravity=\"center\" android:src=\"@drawable/reindeer\" /> </LinearLayout> <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:orientation=\"horizontal\" > <View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:visibility=\"invisible\" /> <ImageButton android:id=\"@+id/btn_character_snowman\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:adjustViewBounds=\"true\" android:background=\"@drawable/dasher_ripple\" android:onClick=\"onCharacterClick\" android:scaleType=\"fitCenter\" android:layout_gravity=\"top\" android:src=\"@drawable/snowman\" /> <View android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" android:visibility=\"invisible\" /> </LinearLayout> </LinearLayout><s><start> # Airspeed Velocity `pandera`'s performance benchmarks over time can be [viewed on this airspeed-velocity dashboard](https://pandera-dev.github.io/pandera-asv-logs/). The [config](https://github.com/pandera-dev/pandera-asv-logs/tree/master/asv_bench/asv.conf.json) and [results files](https://github.com/pandera-dev/pandera-asv-logs/tree/master/results) files are tracked in the [pandera-asv-logs](https://github.com/pandera-dev/pandera-asv-logs) repo to avoid build files in the main repo. The [benchmarks](https://github.com/pandera-dev"}
{"text": "; }; IncomingForm.prototype._initOctetStream = function() { this.type = 'octet-stream'; var filename = this.headers['x-file-name']; var mime = this.headers['content-type']; var file = new File({ path: this._uploadPath(filename), name: filename, type: mime }); this.emit('fileBegin', filename, file); file.open(); this._flushing++; var self = this; self._parser = new OctetParser(); //Keep track of writes that haven't finished so we don't emit the file before it's done being written var outstandingWrites = 0; self._parser.on('data', function(buffer){ self.pause(); outstandingWrites++; file.write(buffer, function() { outstandingWrites--; self.resume(); if(self.ended){ self._parser.emit('doneWritingFile'); } }); }); self._parser.on('end', function(){ self._flushing--; self.ended = true; var done = function(){ file.end(function() { self.emit('file', 'file', file); self._maybeEnd(); }); }; if(outstandingWrites === 0){ done(); } else { self._parser.once('doneWritingFile', done); } }); }; IncomingForm.prototype._initJSONencoded = function() { this.type = 'json'; var parser = new JSONParser() , self = this; if (this.bytesExpected) { parser.initWithLength(this.bytesExpected); } parser.onField = function(key, val) { self.emit('field', key, val); }; parser.onEnd = function() { self.ended = true; self._maybeEnd(); }; this._parser = parser; }; IncomingForm.prototype._uploadPath = function(filename) { var name = 'upload_'; var buf = crypto.randomBytes(16); for (var i = 0; i < buf.length; ++i) { name += ('0' + buf[i].toString(16)).slice(-2); } if (this.keepExtensions) { var ext = path.extname(filename); ext = ext.replace(/(\\.[a-z0-9]+).*/i, '$1'); name +="}
{"text": "/pandera/tree/master/benchmarks/) are tracked in the main [pandera repo](https://github.com/pandera-dev/pandera). ## Running `asv` Ensure both the `pandera` and `pandera-asv-logs` repos are checked out to the same parent directory. From the `pandera-asv-logs` repo, run: ``` asv run ALL --config asv_bench/asv.conf.json ``` ## Publishing results: To build the html and preview the results: ``` asv publish --config asv_bench/asv.conf.json asv preview --config asv_bench/asv.conf.json ``` The `.json` results files are committed or PR'd into the master branch of `pandera-asv-logs`. The published html is pushed directly to the gh-pages branch of `pandera-asv-logs` by running: ``` asv gh-pages --rewrite --config asv_bench/asv.conf.json ``` The `--rewrite` flag overwrites the existing `gh-pages`, avoiding duplication of data. The `asv` docs are [here](https://asv.readthedocs.io/en/stable/index.html).<s><start> var baseSum = require('./_baseSum'), identity = require('./identity'); /** * Computes the sum of the values in `array`. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // => 20 */ function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; } module.exports = sum;<s><start> # coding=utf-8 # -------------------------------------------------------------------------- # Copyright (c) Microsoft Corporation. All rights reserved. # Licensed under the MIT License. See License.txt in the project root for # license information. # # Code generated by Microsoft (R) AutoRest Code Generator. # Changes may cause incorrect behavior and will be lost if the code is # regener"}
{"text": "ext; } return path.join(this.uploadDir, name); }; IncomingForm.prototype._maybeEnd = function() { if (!this.ended || this._flushing || this.error) { return; } this.emit('end'); };<s><start> <!-- ============ PROGRESS --> <!-- ====================== --> <h1>Progress</h1> <!-- ============ VARIABLES --> <!-- ====================== --> <p> <h4>Global variables</h4> <div><pre hljs class=\"prettyprint lang-sass\">$progress-class: \"-progress\" !global $progress-bar-class: \"-bar\" !global $progress-bar-padding-vertical: $base-padding-vertical / 3 $progress-bar-padding-horizontal: $base-padding-horizontal / 1.5 $progress-font-weight: 600 !global $progress-border-radius: 4px !global $progress-border-width: 0px !global $progress-border-style: solid !global $progress-padding: 3px !global $progress-background: #fff !global</pre></div> </p> <p> Use widget class <code>-progress</code>. Apply themes and sizes. Append <code>-bar</code> inside <code>-progress</code>. </p> <div class=\"-row example-block\"> <div class=\"-col12 view\"> <div class=\"-progress -primary-\"> <div class=\"-bar\" style=\"width: 12%\">12 %</div><div class=\"-bar -warning-\" style=\"width: 25%\">25 %</div><div class=\"-bar -error-\" style=\"width: 5%\">Something goes wrong</div> </div> <br> <div class=\"-progress _divine -primary-\"> <div class=\"-bar\" style=\"width: 12%\">12 %</div> </div> <br> <div class=\"-progress -primary- -shadow-curve-\"> <div class=\"-bar\" style=\"width: 42%\">progress with shadow 42 %</div><div class=\"-bar -warning-\" style=\"width: 25%\">25 %</div> </"}
{"text": "ated. # -------------------------------------------------------------------------- from msrest.serialization import Model class StorageProfile(Model): \"\"\"Storage Profile properties of a server. :param backup_retention_days: Backup retention days for the server. :type backup_retention_days: int :param geo_redundant_backup: Enable Geo-redundant or not for server backup. Possible values include: 'Enabled', 'Disabled' :type geo_redundant_backup: str or ~azure.mgmt.rdbms.mariadb.models.GeoRedundantBackup :param storage_mb: Max storage allowed for a server. :type storage_mb: int \"\"\" _attribute_map = { 'backup_retention_days': {'key': 'backupRetentionDays', 'type': 'int'}, 'geo_redundant_backup': {'key': 'geoRedundantBackup', 'type': 'str'}, 'storage_mb': {'key': 'storageMB', 'type': 'int'}, } def __init__(self, *, backup_retention_days: int=None, geo_redundant_backup=None, storage_mb: int=None, **kwargs) -> None: super(StorageProfile, self).__init__(**kwargs) self.backup_retention_days = backup_retention_days self.geo_redundant_backup = geo_redundant_backup self.storage_mb = storage_mb<s><start> <html> <head> <meta HTTP-EQUIV=\"Context-Type\" CONTEXT=\"text/html;charset=windows-1252\"> <meta name=\"GENERATOR\" content=\"Microsoft FrontPage 3.0\"> <title>tr Summary</title> </head> <body> <h1>tr Summary</h1> <ul> <li><h2>tr input MUST come from standard input </h2> </li> </ul> <ul> <li><h2>tr does NOT change the input file but puts its modified values on standard output </h2> </li> </ul> <ul> <li><h2>recognizes the range, set regular expressions </h2> </li> </ul> <ul> <li"}
{"text": "div> <br> <div class=\"-progress -primary- -shadow-lifted-\"> <div class=\"-bar\" style=\"width: 42%\">progress with shadow 42 %</div> </div> </div> <div class=\"-col12 example\"><pre hljs class=\"prettyprint lang-html\"><div class=\"-progress -primary-\"> <div class=\"-bar\" style=\"width: 12%\">12 %</div> <div class=\"-bar -warning-\" style=\"width: 25%\">25 %</div> <div class=\"-bar -error-\" style=\"width: 5%\">Something goes wrong</div> </div> <div class=\"-progress _divine -primary-\"> <div class=\"-bar\" style=\"width: 12%\">12 %</div> </div> </pre></div> </div><s><start> // This file is part of Eigen, a lightweight C++ template library // for linear algebra. // // Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr> // // This Source Code Form is subject to the terms of the Mozilla // Public License v. 2.0. If a copy of the MPL was not distributed // with this file, You can obtain one at http://mozilla.org/MPL/2.0/. #ifndef EIGEN_REF_H #define EIGEN_REF_H namespace Eigen { template<typename Derived> class RefBase; template<typename PlainObjectType, int Options = 0, typename StrideType = typename internal::conditional<PlainObjectType::IsVectorAtCompileTime,InnerStride<1>,OuterStride<> >::type > class Ref; /** \\class Ref * \\ingroup Core_Module * * \\brief A matrix or vector expression mapping an existing expressions * * \\tparam PlainObjectType the equivalent matrix type of the mapped data * \\tparam Options specifies whether the pointer is \\c #Aligned, or \\c #Unaligned. * The default is \\c #Unaligned. * \\tparam StrideType optionally specifies strides. By default, Ref implies a contiguous storage along"}
{"text": "><h2>if more than a single character then characters replaced match up on left with characters which replace them (i.e. &#147;qex&#148; &#147;abc </h2> <ul> <li>a for a </li> <li>b for e </li> <li>c for x </li> </ul> </li> </ul> <ul> <li><h2>characters can be deleted with the -d option </h2> </li> </ul> <ul> <li><h2>multiple characters removed with the -s option </h2> </li> </ul> <ul> <li>&nbsp;</li> </ul> <table> <tr> <td HEIGHT=\"100\" WIDTH=\"100\"><a HREF=\"tsld019.htm\">Previous slide</a> </td> <td HEIGHT=\"100\" WIDTH=\"100\"></td> <td HEIGHT=\"100\" WIDTH=\"150\"><a HREF=\"tsld001.htm\">Back to first slide</a> </td> <td HEIGHT=\"100\" WIDTH=\"150\"></td> </tr> </table> <p><br> </p> </body> </html><s><start> \ufeff<Project ToolsVersion=\"3.5\" DefaultTargets=\"Default\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"> <PropertyGroup> <TPath>$(MSBuildProjectDirectory)\\..\\MSBuild.ExtensionPack.tasks</TPath> <TPath Condition=\"Exists('$(MSBuildProjectDirectory)\\..\\..\\Common\\MSBuild.ExtensionPack.tasks')\">$(MSBuildProjectDirectory)\\..\\..\\Common\\MSBuild.ExtensionPack.tasks</TPath> </PropertyGroup> <Import Project=\"$(TPath)\"/> <Target Name=\"Default\"> <ItemGroup> <Database Include=\"ADatabase\"> <NewName>ADatabase2</NewName> </Database> <Database2 Include=\"ADatabase2\"> <NewName>ADatabase</NewName> </Database2> </ItemGroup> <!-- Get information on a database --> <M"}
{"text": "the inner dimension (inner stride==1), * but accept a variable outer stride (leading dimension). * This can be overridden by specifying strides. * The type passed here must be a specialization of the Stride template, see examples below. * * This class permits to write non template functions taking Eigen's object as parameters while limiting the number of copies. * A Ref<> object can represent either a const expression or a l-value: * \\code * // in-out argument: * void foo1(Ref<VectorXf> x); * * // read-only const argument: * void foo2(const Ref<const VectorXf>& x); * \\endcode * * In the in-out case, the input argument must satisfies the constraints of the actual Ref<> type, otherwise a compilation issue will be triggered. * By default, a Ref<VectorXf> can reference any dense vector expression of float having a contiguous memory layout. * Likewise, a Ref<MatrixXf> can reference any column major dense matrix expression of float whose column's elements are contiguously stored with * the possibility to have a constant space inbetween each column, i.e.: the inner stride mmust be equal to 1, but the outer-stride (or leading dimension), * can be greater than the number of rows. * * In the const case, if the input expression does not match the above requirement, then it is evaluated into a temporary before being passed to the function. * Here are some examples: * \\code * MatrixXf A; * VectorXf a; * foo1(a.head()); // OK * foo1(A.col()); // OK * foo1(A.row()); // compilation error because here innerstride!=1 * foo2(A.row()); // The row is copied into a contiguous temporary * foo2(2*a); // The expression is evaluated into a temporary * foo2(A.col().segment(2,4)); // No temporary * \\endcode * * The range of inputs that can be referenced without temporary can be enlarged using the last two template parameter. * Here is an example accepting an innerstride!=1: * \\code * // in-out argument: * void foo3(Ref<VectorXf,0,InnerStride<> > x); * foo3(A.row()); // OK"}
{"text": "SBuild.ExtensionPack.Sql2012.Database TaskAction=\"GetInfo\" DatabaseItem=\"ADatabase\"> <Output TaskParameter=\"Information\" ItemName=\"AllInfo\"/> </MSBuild.ExtensionPack.Sql2012.Database> <!-- All the database information properties are available as metadata on the Infomation item --> <Message Text=\"SpaceAvailable: %(AllInfo.SpaceAvailable)\"/> <!-- Backup a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Backup\" DatabaseItem=\"ADatabase\" DataFilePath=\"c:\\a\\ADatabase.bak\"/> <!-- Verify a database backup --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"VerifyBackup\" DataFilePath=\"c:\\a\\ADatabase.bak\"/> <!-- Restore a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Restore\" DatabaseItem=\"ADatabase\" DataFilePath=\"c:\\a\\ADatabase.bak\"/> <!-- Restore a database to a different location--> <MSBuild.ExtensionPack.Sql2012.Database MachineName=\"Desktop\\Sql2012\" TaskAction=\"Restore\" DatabaseItem=\"ADatabase\" DataFilePath=\"c:\\a\\ADatabase.bak\" NewDataFilePath=\"c:\\k\\ADatabase2.mdf\" LogFilePath=\"c:\\a\\ADatabase2_log.LDF\"/> <!-- Create a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Create\" DatabaseItem=\"ADatabase2\"/> <!-- Create the database again, using Force to delete the existing database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Create\" DatabaseItem=\"ADatabase2\" Collation=\"Latin1_General_CI_AI\" Force=\"true\"/> <!-- Check whether a database exists --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"CheckExists\" DatabaseItem=\"ADatabase2\"> <Output TaskParameter=\"Exists\" PropertyName=\"DoesExist\"/> </MSBuild.ExtensionPack.Sql2012.Database> <Message Text=\"Database Exists: $(DoesExist)\"/> <!-- Delete a database --> <MSBuild.ExtensionPack"}
{"text": "* \\endcode * The downside here is that the function foo3 might be significantly slower than foo1 because it won't be able to exploit vectorization, and will involved more * expensive address computations even if the input is contiguously stored in memory. To overcome this issue, one might propose to overloads internally calling a * template function, e.g.: * \\code * // in the .h: * void foo(const Ref<MatrixXf>& A); * void foo(const Ref<MatrixXf,0,Stride<> >& A); * * // in the .cpp: * template<typename TypeOfA> void foo_impl(const TypeOfA& A) { * ... // crazy code goes here * } * void foo(const Ref<MatrixXf>& A) { foo_impl(A); } * void foo(const Ref<MatrixXf,0,Stride<> >& A) { foo_impl(A); } * \\endcode * * * \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders */ namespace internal { template<typename _PlainObjectType, int _Options, typename _StrideType> struct traits<Ref<_PlainObjectType, _Options, _StrideType> > : public traits<Map<_PlainObjectType, _Options, _StrideType> > { typedef _PlainObjectType PlainObjectType; typedef _StrideType StrideType; enum { Options = _Options, Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit }; template<typename Derived> struct match { enum { HasDirectAccess = internal::has_direct_access<Derived>::ret, StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)), InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic) || int(StrideType::InnerStrideAtCompileTime)==int(Derived::InnerStrideAtCompileTime) || (int(StrideType::InnerStrideAtCompileTime)==0 && int(Derived::InnerStrideAtComp"}
{"text": ".Sql2012.Database TaskAction=\"Delete\" DatabaseItem=\"ADatabase2\"/> <!-- Check whether a database exists --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"CheckExists\" DatabaseItem=\"ADatabase2\"> <Output TaskParameter=\"Exists\" PropertyName=\"DoesExist\"/> </MSBuild.ExtensionPack.Sql2012.Database> <Message Text=\"Database Exists: $(DoesExist)\"/> <!-- Get the number of active connections to a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"GetConnectionCount\" DatabaseItem=\"ADatabase\"> <Output TaskParameter=\"ConnectionCount\" PropertyName=\"Count\"/> </MSBuild.ExtensionPack.Sql2012.Database> <Message Text=\"Database ConnectionCount: $(Count)\"/> <!-- Delete the backup history for a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"DeleteBackupHistory\" DatabaseItem=\"ADatabase\"/> <!-- Set a database offline --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"SetOffline\" DatabaseItem=\"ADatabase\"/> <!-- Set a database online --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"SetOnline\" DatabaseItem=\"ADatabase\"/> <!-- Rename a database --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Rename\" DatabaseItem=\"@(Database)\"/> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Rename\" DatabaseItem=\"@(Database2)\"/> <!-- Script a database to file --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Script\" DatabaseItem=\"ReportServer\" OutputFilePath=\"c:\\ADatabaseScript.sql\"/> <!-- Restore a database to a new Name --> <MSBuild.ExtensionPack.Sql2012.Database TaskAction=\"Restore\" MachineName=\"$(SqlServerName)\" DatabaseItem=\"$(DatabaseName)\" DataFilePath=\"$(DbDataFilePath)\" PrimaryDataFileName=\"SomeDatabase\" LogName=\"SomeDatabase_log\" SecondaryDataFileName=\"SomeDatabase_CDC\" NewDataFilePath=\"$(OSFilePath)$(DatabaseName).mdf\" SecondaryDataFilePath=\"$(OS"}
{"text": "ileTime)==1), OuterStrideMatch = Derived::IsVectorAtCompileTime || int(StrideType::OuterStrideAtCompileTime)==int(Dynamic) || int(StrideType::OuterStrideAtCompileTime)==int(Derived::OuterStrideAtCompileTime), AlignmentMatch = (_Options!=Aligned) || ((PlainObjectType::Flags&AlignedBit)==0) || ((traits<Derived>::Flags&AlignedBit)==AlignedBit), MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch }; typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type; }; }; template<typename Derived> struct traits<RefBase<Derived> > : public traits<Derived> {}; } template<typename Derived> class RefBase : public MapBase<Derived> { typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType; typedef typename internal::traits<Derived>::StrideType StrideType; public: typedef MapBase<Derived> Base; EIGEN_DENSE_PUBLIC_INTERFACE(RefBase) inline Index innerStride() const { return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1; } inline Index outerStride() const { return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer() : IsVectorAtCompileTime ? this->size() : int(Flags)&RowMajorBit ? this->cols() : this->rows(); } RefBase() : Base(0,RowsAtCompileTime==Dynamic?0:RowsAtCompileTime,ColsAtCompileTime==Dynamic?0:ColsAtCompileTime), // Stride<> does not allow default ctor for Dynamic strides, so let' initialize it with dummy values: m_stride(StrideType::OuterStrideAtCompileTime==Dynamic?0:StrideType::OuterStrideAtCompileTime, StrideType::InnerStrideAtCompileTime==Dynamic?0:StrideType"}
{"text": "FilePath)$(DatabaseName)_CDC.ndf\" LogFilePath=\"$(OSFilePath)\\$(DatabaseName)_log.ldf\" ReplaceDatabase=\"True\" /> </Target> </Project><s><start> \ufeffnamespace ScriptableObjectArchitecture { public static class SOArchitecture_Utility { public const int ASSET_MENU_ORDER_VARIABLES = 121; public const int ASSET_MENU_ORDER_EVENTS = 122; public const int ASSET_MENU_ORDER_COLLECTIONS = 123; public const string VARIABLE_SUBMENU = \"Variables/\"; public const string COLLECTION_SUBMENU = \"Collections/\"; public const string GAME_EVENT = \"Game Events/\"; public const string ADVANCED_GAME_EVENT = GAME_EVENT + \"Advanced/\"; public const string ADVANCED_VARIABLE_SUBMENU = VARIABLE_SUBMENU + \"Advanced/\"; public const string ADVANCED_VARIABLE_COLLECTION = COLLECTION_SUBMENU + \"Advanced/\"; // Add Component Menus public const string ADD_COMPONENT_ROOT_MENU = \"SO Architecture/\"; public const string EVENT_LISTENER_SUBMENU = ADD_COMPONENT_ROOT_MENU + \"Event Listeners/\"; } }<s><start> package net.sgoliver.android.controlpers2; import android.content.Context; import android.content.res.TypedArray; import android.util.AttributeSet; import android.view.LayoutInflater; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.LinearLayout; import android.widget.TextView; public class ControlLogin extends LinearLayout { private EditText txtUsuario; private EditText txtPassword; private Button btnLogin; private TextView lblMensaje; private OnLoginListener listener; public ControlLogin(Context context) { super(context); inicializar(); } public ControlLogin(Context context, AttributeSet attrs) { super(context, attrs); inicializar(); // Procesamos los atributos XML personalizados TypedArray a = getContext().ob"}
{"text": "::InnerStrideAtCompileTime) {} EIGEN_INHERIT_ASSIGNMENT_OPERATORS(RefBase) protected: typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase; template<typename Expression> void construct(Expression& expr) { if(PlainObjectType::RowsAtCompileTime==1) { eigen_assert(expr.rows()==1 || expr.cols()==1); ::new (static_cast<Base*>(this)) Base(expr.data(), 1, expr.size()); } else if(PlainObjectType::ColsAtCompileTime==1) { eigen_assert(expr.rows()==1 || expr.cols()==1); ::new (static_cast<Base*>(this)) Base(expr.data(), expr.size(), 1); } else ::new (static_cast<Base*>(this)) Base(expr.data(), expr.rows(), expr.cols()); ::new (&m_stride) StrideBase(StrideType::OuterStrideAtCompileTime==0?0:expr.outerStride(), StrideType::InnerStrideAtCompileTime==0?0:expr.innerStride()); } StrideBase m_stride; }; template<typename PlainObjectType, int Options, typename StrideType> class Ref : public RefBase<Ref<PlainObjectType, Options, StrideType> > { typedef internal::traits<Ref> Traits; public: typedef RefBase<Ref> Base; EIGEN_DENSE_PUBLIC_INTERFACE(Ref) #ifndef EIGEN_PARSED_BY_DOXYGEN template<typename Derived> inline Ref(PlainObjectBase<Derived>& expr, typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0) { Base::construct(expr); } template<typename Derived> inline Ref(const DenseBase<Derived>& expr, typename internal::enable_if<bool(internal::is_lvalue<Derived>::value&&bool(Traits::template match<Derived>::MatchAtCompileTime)),Derived>::"}
{"text": "tainStyledAttributes(attrs, R.styleable.ControlLogin); String textoBoton = a.getString( R.styleable.ControlLogin_login_text); btnLogin.setText(textoBoton); a.recycle(); } private void inicializar() { //Utilizamos el layout 'control_login' como interfaz del control String infService = Context.LAYOUT_INFLATER_SERVICE; LayoutInflater li = (LayoutInflater)getContext().getSystemService(infService); li.inflate(R.layout.control_login, this, true); //Obtenemoslas referencias a los distintos control txtUsuario = (EditText)findViewById(R.id.TxtUsuario); txtPassword = (EditText)findViewById(R.id.TxtPassword); btnLogin = (Button)findViewById(R.id.BtnAceptar); lblMensaje = (TextView)findViewById(R.id.LblMensaje); //Asociamos los eventos necesarios asignarEventos(); } public void setOnLoginListener(OnLoginListener l) { listener = l; } private void asignarEventos() { btnLogin.setOnClickListener(new OnClickListener() { public void onClick(View v) { listener.onLogin(txtUsuario.getText().toString(), txtPassword.getText().toString()); } }); } public void setMensaje(String msg) { lblMensaje.setText(msg); } }<s><start> <?xml version=\"1.0\" standalone=\"no\" ?> <!DOCTYPE pov SYSTEM \"/usr/share/cgc-docs/replay.dtd\"> <pov> <cbid>service</cbid> <replay> <write><data>UUUUUUUU</data></write> <read><delim>\\x0a</delim><match><data>What is your name?\\x0a</data></match></read> <write><data>User\\x0a</data></write> <read><delim>\\x0a</delim><match><data>Hi\\x2c User\\x0a</data></match></read> <read><delim>\\x3e</delim><match><pcre>.*?0 B ></pcre></match></read> <"}
{"text": "type* = 0, int = Derived::ThisConstantIsPrivateInPlainObjectBase) #else template<typename Derived> inline Ref(DenseBase<Derived>& expr) #endif { Base::construct(expr.const_cast_derived()); } EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Ref) }; // this is the const ref version template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType> : public RefBase<Ref<const TPlainObjectType, Options, StrideType> > { typedef internal::traits<Ref> Traits; public: typedef RefBase<Ref> Base; EIGEN_DENSE_PUBLIC_INTERFACE(Ref) template<typename Derived> inline Ref(const DenseBase<Derived>& expr) { // std::cout << match_helper<Derived>::HasDirectAccess << \",\" << match_helper<Derived>::OuterStrideMatch << \",\" << match_helper<Derived>::InnerStrideMatch << \"\\n\"; // std::cout << int(StrideType::OuterStrideAtCompileTime) << \" - \" << int(Derived::OuterStrideAtCompileTime) << \"\\n\"; // std::cout << int(StrideType::InnerStrideAtCompileTime) << \" - \" << int(Derived::InnerStrideAtCompileTime) << \"\\n\"; construct(expr.derived(), typename Traits::template match<Derived>::type()); } protected: template<typename Expression> void construct(const Expression& expr,internal::true_type) { Base::construct(expr); } template<typename Expression> void construct(const Expression& expr, internal::false_type) { m_object.lazyAssign(expr); Base::construct(m_object); } protected: TPlainObjectType m_object; }; } // end namespace Eigen #endif // EIGEN_REF_H<s><start> fileFormatVersion: 2 guid: c6be551879cd14d739b0188844ef2c60 timeCreated: 1447582131 licenseType: Pro MonoImporter"}
{"text": "write><data>7 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?1 B ></pcre></match></read> <write><data>3 2\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?2 B ></pcre></match></read> <write><data>18 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?3 B ></pcre></match></read> <write><data>5 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?4 B ></pcre></match></read> <write><data>8 1\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?5 B ></pcre></match></read> <write><data>0 9\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?6 B ></pcre></match></read> <write><data>6 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?7 B ></pcre></match></read> <write><data>19 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?7 B ></pcre></match></read> <write><data>5 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?8 B ></pcre></match></read> <write><data>11 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?9 B ></pcre></match></read> <write><data>2 3\\x0a</data></write> <read><delim>\\x3e</"}
{"text": ": serializedVersion: 2 defaultReferences: [] executionOrder: 0 icon: {fileID: 2800000, guid: e1e5ef31262d242ce8efe2020a27425e, type: 3} userData: assetBundleName: assetBundleVariant:<s><start> { \"images\" : [ { \"idiom\" : \"watch\", \"scale\" : \"2x\", \"screen-width\" : \"<=145\" }, { \"idiom\" : \"watch\", \"scale\" : \"2x\", \"screen-width\" : \">161\" }, { \"idiom\" : \"watch\", \"scale\" : \"2x\", \"screen-width\" : \">145\" }, { \"idiom\" : \"watch\", \"scale\" : \"2x\", \"screen-width\" : \">183\" } ], \"info\" : { \"version\" : 1, \"author\" : \"xcode\" } }<s><start> <import src=\"../../../common/head.wxml\"/> <import src=\"../../../common/foot.wxml\"/> <view class=\"container\"> <template is=\"head\" data=\"{{title: 'sendMessage'}}\"/> <view class=\"page-body\"> <view class=\"weui-cells__title\">\u53d1\u9001\u5185\u5bb9\uff08\u4ee5\u4e0b\u5b57\u6bb5\u53ef\u81ea\u7531\u9002\u914d\uff09</view> <view class=\"weui-cells weui-cells_after-title\"> <view class=\"weui-cell weui-cell_input\"> <view class=\"weui-cell__hd\"> <view class=\"weui-label\">\u5b9e\u4f8b\u5b57\u6bb5</view> </view> <view class=\"weui-cell__bd\"> <input class=\"weui-input\" type=\"text\" placeholder=\"\u8bf7\u8f93\u5165\"></input> </view> </view> <view class=\"weui-cell weui-cell_input\"> <view class=\"weui-cell__hd\"> <view class=\"weui-label\">\u5b9e\u4f8b\u5b57\u6bb5</view> </view> <view class=\"weui-cell__bd\"> <input class=\"weui-input\" type=\"text\" placeholder=\"\u8bf7\u8f93\u5165\"></input> </view> </view> </view> <view"}
{"text": "delim><match><pcre>.*?10 B ></pcre></match></read> <write><data>11 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?11 B ></pcre></match></read> <write><data>16 18\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?12 B ></pcre></match></read> <write><data>9 5\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?13 B ></pcre></match></read> <write><data>16 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?14 B ></pcre></match></read> <write><data>11 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?15 B ></pcre></match></read> <write><data>10 3\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?16 B ></pcre></match></read> <write><data>10 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?17 B ></pcre></match></read> <write><data>0 3\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?17 B ></pcre></match></read> <write><data>14 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?18 B ></pcre></match></read> <write><data>0 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?"}
{"text": "class=\"weui-cells\"> <view class=\"weui-cell weui-cell_input\"> <view class=\"weui-cell__hd\"> <view class=\"weui-label\">\u8df3\u8f6c\u94fe\u63a5</view> </view> <view class=\"weui-cell__bd\"> <input class=\"weui-input\" type=\"text\" placeholder=\"\u8bf7\u8f93\u5165\" value=\"{{shareData.path}}\"></input> </view> </view> </view> <view class=\"btn-area\"> <button type=\"primary\">\u53d1\u9001\u6a21\u677f\u6d88\u606f</button> </view> </view> <template is=\"foot\"/> </view><s><start> // Copyright (C) 2005-2006 The Trustees of Indiana University. // Use, modification and distribution is subject to the Boost Software // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at // http://www.boost.org/LICENSE_1_0.txt) // Authors: Douglas Gregor // Andrew Lumsdaine #ifndef BOOST_GRAPH_DETAIL_REMOTE_UPDATE_SET_HPP #define BOOST_GRAPH_DETAIL_REMOTE_UPDATE_SET_HPP #ifndef BOOST_GRAPH_USE_MPI #error \"Parallel BGL files should not be included unless <boost/graph/use_mpi.hpp> has been included\" #endif #include <boost/graph/parallel/process_group.hpp> #include <boost/type_traits/is_convertible.hpp> #include <vector> #include <boost/assert.hpp> #include <boost/optional.hpp> #include <queue> namespace boost { namespace graph { namespace detail { template<typename ProcessGroup> void do_synchronize(ProcessGroup& pg) { using boost::parallel::synchronize; synchronize(pg); } struct remote_set_queued {}; struct remote_set_immediate {}; template<typename ProcessGroup> class remote_set_semantics { BOOST_STATIC_CONSTANT (bool, queued = (is_convertible< typename ProcessGroup::communication_category, boost::parallel::bsp_"}
{"text": "19 B ></pcre></match></read> <write><data>11 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?19 B ></pcre></match></read> <write><data>6 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?20 B ></pcre></match></read> <write><data>4 19\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?20 B ></pcre></match></read> <write><data>17 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?21 B ></pcre></match></read> <write><data>7 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?22 B ></pcre></match></read> <write><data>17 19\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?22 B ></pcre></match></read> <write><data>18 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?23 B ></pcre></match></read> <write><data>0 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?24 B ></pcre></match></read> <write><data>10 2\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?25 B ></pcre></match></read> <write><data>9 15\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?26 B ></pcre></match"}
{"text": "process_group_tag>::value)); public: typedef typename mpl::if_c<queued, remote_set_queued, remote_set_immediate>::type type; }; template<typename Derived, typename ProcessGroup, typename Value, typename OwnerMap, typename Semantics = typename remote_set_semantics<ProcessGroup>::type> class remote_update_set; /********************************************************************** * Remote updating set that queues messages until synchronization * **********************************************************************/ template<typename Derived, typename ProcessGroup, typename Value, typename OwnerMap> class remote_update_set<Derived, ProcessGroup, Value, OwnerMap, remote_set_queued> { typedef typename property_traits<OwnerMap>::key_type Key; typedef std::vector<std::pair<Key, Value> > Updates; typedef typename Updates::size_type updates_size_type; typedef typename Updates::value_type updates_pair_type; public: private: typedef typename ProcessGroup::process_id_type process_id_type; enum message_kind { /** Message containing the number of updates that will be sent in * a msg_updates message that will immediately follow. This * message will contain a single value of type * updates_size_type. */ msg_num_updates, /** Contains (key, value) pairs with all of the updates from a * particular source. The number of updates is variable, but will * be provided in a msg_num_updates message that immediately * preceeds this message. * */ msg_updates }; struct handle_messages { explicit handle_messages(remote_update_set* self, const ProcessGroup& pg) : self(self), update_sizes(num_processes(pg), 0) { } void operator()(process_id_type source, int tag) { switch(tag) { case msg_num_updates: { // Receive the # of updates updates_size_type num_updates; receive(self->process_group, source, tag, num_updates); update_sizes[source] = num_updates; } break; case msg_updates: { updates_size_type num_updates = update_sizes[source]; BOOST_ASSERT"}
{"text": "></read> <write><data>2 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?27 B ></pcre></match></read> <write><data>6 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?28 B ></pcre></match></read> <write><data>9 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?29 B ></pcre></match></read> <write><data>7 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?30 B ></pcre></match></read> <write><data>4 10\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?31 B ></pcre></match></read> <write><data>18 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?31 B ></pcre></match></read> <write><data>7 9\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?32 B ></pcre></match></read> <write><data>1 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?33 B ></pcre></match></read> <write><data>14 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?34 B ></pcre></match></read> <write><data>2 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?35 B ></pcre></match></read> <write><data>10 2\\x0a"}
{"text": "(num_updates); // Receive the actual updates std::vector<updates_pair_type> updates(num_updates); receive(self->process_group, source, msg_updates, &updates[0], num_updates); // Send updates to derived \"receive_update\" member Derived* derived = static_cast<Derived*>(self); for (updates_size_type u = 0; u < num_updates; ++u) derived->receive_update(source, updates[u].first, updates[u].second); update_sizes[source] = 0; } break; }; } private: remote_update_set* self; std::vector<updates_size_type> update_sizes; }; friend struct handle_messages; protected: remote_update_set(const ProcessGroup& pg, const OwnerMap& owner) : process_group(pg, handle_messages(this, pg)), updates(num_processes(pg)), owner(owner) { } void update(const Key& key, const Value& value) { if (get(owner, key) == process_id(process_group)) { Derived* derived = static_cast<Derived*>(this); derived->receive_update(get(owner, key), key, value); } else { updates[get(owner, key)].push_back(std::make_pair(key, value)); } } void collect() { } void synchronize() { // Emit all updates and then remove them process_id_type num_processes = updates.size(); for (process_id_type p = 0; p < num_processes; ++p) { if (!updates[p].empty()) { send(process_group, p, msg_num_updates, updates[p].size()); send(process_group, p, msg_updates, &updates[p].front(), updates[p].size()); updates[p].clear(); } } do_synchronize(process_group); } ProcessGroup process_group; private: std::vector<Updates> updates; OwnerMap owner; }; /********************************************************************** * Remote updating set that sends messages immediately * **********************************************************************/ template<typename Derived, typename ProcessGroup, typename"}
{"text": "</data></write> <read><delim>\\x3e</delim><match><pcre>.*?35 B ></pcre></match></read> <write><data>7 0\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?36 B ></pcre></match></read> <write><data>14 9\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?37 B ></pcre></match></read> <write><data>16 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?38 B ></pcre></match></read> <write><data>14 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?39 B ></pcre></match></read> <write><data>17 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?40 B ></pcre></match></read> <write><data>12 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?41 B ></pcre></match></read> <write><data>1 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?42 B ></pcre></match></read> <write><data>12 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?43 B ></pcre></match></read> <write><data>0 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?44 B ></pcre></match></read> <write><data>18 10\\x0a</data></write> <read><delim"}
{"text": "Value, typename OwnerMap> class remote_update_set<Derived, ProcessGroup, Value, OwnerMap, remote_set_immediate> { typedef typename property_traits<OwnerMap>::key_type Key; typedef std::pair<Key, Value> update_pair_type; typedef typename std::vector<update_pair_type>::size_type updates_size_type; public: typedef typename ProcessGroup::process_id_type process_id_type; private: enum message_kind { /** Contains a (key, value) pair that will be updated. */ msg_update }; struct handle_messages { explicit handle_messages(remote_update_set* self, const ProcessGroup& pg) : self(self) { update_sizes.resize(num_processes(pg), 0); } void operator()(process_id_type source, int tag) { // Receive the # of updates BOOST_ASSERT(tag == msg_update); update_pair_type update; receive(self->process_group, source, tag, update); // Send update to derived \"receive_update\" member Derived* derived = static_cast<Derived*>(self); derived->receive_update(source, update.first, update.second); } private: std::vector<updates_size_type> update_sizes; remote_update_set* self; }; friend struct handle_messages; protected: remote_update_set(const ProcessGroup& pg, const OwnerMap& owner) : process_group(pg, handle_messages(this, pg)), owner(owner) { } void update(const Key& key, const Value& value) { if (get(owner, key) == process_id(process_group)) { Derived* derived = static_cast<Derived*>(this); derived->receive_update(get(owner, key), key, value); } else send(process_group, get(owner, key), msg_update, update_pair_type(key, value)); } void collect() { typedef std::pair<process_id_type, int> probe_type; handle_messages handler(this, process_group); while (optional<probe_type> stp = probe(process_group)) if (stp->second == msg_update"}
{"text": ">\\x3e</delim><match><pcre>.*?45 B ></pcre></match></read> <write><data>pass\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?46 B ></pcre></match></read> <write><data>5 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?47 B ></pcre></match></read> <write><data>17 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?48 B ></pcre></match></read> <write><data>8 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?49 B ></pcre></match></read> <write><data>8 3\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?50 B ></pcre></match></read> <write><data>10 10\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?51 B ></pcre></match></read> <write><data>7 5\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?52 B ></pcre></match></read> <write><data>0 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?52 B ></pcre></match></read> <write><data>14 3\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?52 B ></pcre></match></read> <write><data>14 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?5"}
{"text": ") handler(stp->first, stp->second); } void synchronize() { do_synchronize(process_group); } ProcessGroup process_group; OwnerMap owner; }; } } } // end namespace boost::graph::detail #endif // BOOST_GRAPH_DETAIL_REMOTE_UPDATE_SET_HPP<s><start> <a href=\"https://www.buymeacoffee.com/7eDr4fv\" target=\"_blank\"><img src=\"https://cdn.buymeacoffee.com/buttons/lato-orange.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important;\" ></a> # 2019-ncov-frontend > Coronavirus (COVID-19) Frontend Backend setup can be found here [2019-ncov-api](https://github.com/sorxrob/2019-ncov-api). ## Project setup ``` npm install ``` ### Compiles and hot-reloads for development ``` npm run serve ``` ### Compiles and minifies for production ``` npm run build ``` ### Lints and fixes files ``` npm run lint ``` ## License & copyright \u00a9 Robert C Soriano Licensed under the [MIT License](LICENSE). ## Acknowledgments - Hat tip to anyone who's module was used - Richard Matsen for radius scale calculation<s><start> type=driver plumed_needs=boost_serialization plumed_modules=drr arg=\"--plumed plumed.dat --trajectory-stride 1 --timestep 0.005 --ixyz ala12_trajectory.xyz --dump-forces forces --dump-forces-fmt=%10.6f\"<s><start> Lets sing! \u266b\u266a\u266c\u2669 Eat food \ud83c\udf45\ud83c\udf55<s><start> import sqlite3 import time import datetime conn = sqlite3.connect('master.db') c = conn.cursor() def create_table(): c.execute('CREATE TABLE IF NOT EXISTS tennis(player TEXT, Pinnacle REAL, WillHill REAL, betThreeSixFive REAL, Book"}
{"text": "2 B ></pcre></match></read> <write><data>1 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?53 B ></pcre></match></read> <write><data>5 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?53 B ></pcre></match></read> <write><data>19 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?53 B ></pcre></match></read> <write><data>9 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?54 B ></pcre></match></read> <write><data>5 19\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?54 B ></pcre></match></read> <write><data>6 0\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?55 B ></pcre></match></read> <write><data>15 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?56 B ></pcre></match></read> <write><data>17 15\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?57 B ></pcre></match></read> <write><data>pass\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?58 B ></pcre></match></read> <write><data>19 1\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?58 B ></pcre></match></read> <write><data>"}
{"text": "maker REAL, BetOnline REAL, TheGreekSportsbook REAL, JustBet REAL, SportsInteraction REAL, WagerWeb REAL, FiveDimes REAL)') \"\"\" Columns are: player betfairBack betfairLay williamhill ladbrokes \"\"\" def dynamic_data_entry(column,entry): c.execute(\"INSERT INTO tennis(\" + column + \") VALUES(?)\", (str(entry),)) conn.commit() #The real function will have to be \"updating\" def update(player,column,entry): c.execute('SELECT * FROM tennis') c.execute(\"UPDATE tennis SET \" + column + \" = \" + str(entry) + \" WHERE player = '\" + player + \"'\") conn.commit() def read_from_db(player): c.execute(\"SELECT * FROM tennis WHERE player = '\" + player + \"'\") # data = c.fetchone() # print data #for row in c.fetchall(): # print row[1:] return list(c.fetchall()) create_table() #c.close() #conn.close()<s><start> \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?> <packages> <package id=\"Dapper\" version=\"1.50.4-alpha1-00070\" targetFramework=\"net452\" /> <package id=\"Dapper.Contrib\" version=\"1.50.0\" targetFramework=\"net452\" /> <package id=\"Dapper.Extension\" version=\"1.0.0.1\" targetFramework=\"net452\" /> <package id=\"EntityFramework\" version=\"6.1.3\" targetFramework=\"net452\" /> <package id=\"SyntacticSugar\" version=\"2.4.1\" targetFramework=\"net452\" /> </packages><s><start> package com.tencent.mm.ui.chatting; import android.view.View; import android.view.ViewStub; import android.view.animation.AnimationUtils; import android.widget.ListView; import com.tencent.mm.e.a.nq; import com.tencent.mm.plugin.sight.encode.ui.ChattingSightContainerView.a; import com.tencent.mm.sdk.c.a; import com"}
{"text": "17 10\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?59 B ></pcre></match></read> <write><data>6 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?60 B ></pcre></match></read> <write><data>2 12\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?60 B ></pcre></match></read> <write><data>17 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?61 B ></pcre></match></read> <write><data>5 5\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?62 B ></pcre></match></read> <write><data>6 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?63 B ></pcre></match></read> <write><data>0 8\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?64 B ></pcre></match></read> <write><data>0 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?64 B ></pcre></match></read> <write><data>0 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?64 B ></pcre></match></read> <write><data>6 10\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?65 B ></pcre></match></read> <write><data>0 13\\x0a</data></write"}
{"text": ".tencent.mm.sdk.platformtools.ac; import com.tencent.mm.ui.j; import com.tencent.mm.ui.o; final class ChattingUI$a$84$2 implements ChattingSightContainerView.a { View lBB = null; ChattingUI$a$84$2(ChattingUI.a.84 param84) {} public final void azd() { nq localnq = new nq(); avS.type = 6; a.kug.y(localnq); lBA.lAY.setRequestedOrientation(1); lBA.lAY.Xk(); lBA.lAY.bkT(); lBA.lAY.blj(); if (lBB == null) { lBB = ((ViewStub)lBA.lAY.findViewById(2131755932)).inflate(); } lBB.setVisibility(0); lBB.startAnimation(AnimationUtils.loadAnimation(lBA.lAY.kNN.kOg, 2130968612)); } public final void onHide() { lBA.lAY.setRequestedOrientation(-1); lBA.lAY.bkT(); if ((lBB != null) && (lBB.getVisibility() == 0)) { lBB.setVisibility(8); lBB.startAnimation(AnimationUtils.loadAnimation(lBA.lAY.kNN.kOg, 2130968613)); } new ac().post(new Runnable() { public final void run() { nq localnq = new nq(); avS.type = 7; avS.avT = ChattingUI.a.e(lBA.lAY).getFirstVisiblePosition(); avS.avU = ChattingUI.a.e(lBA.lAY).getLastVisiblePosition(); avS.avV = ChattingUI.a.e(lBA.lAY).getHeaderViewsCount(); a.kug.y(localnq); } }); } } /* Location: * Qualified Name: com.tencent.mm.ui.chatting.ChattingUI.a.84."}
{"text": "> <read><delim>\\x3e</delim><match><pcre>.*?66 B ></pcre></match></read> <write><data>16 0\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?67 B ></pcre></match></read> <write><data>9 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?68 B ></pcre></match></read> <write><data>8 9\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?69 B ></pcre></match></read> <write><data>11 4\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?69 B ></pcre></match></read> <write><data>1 4\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?69 B ></pcre></match></read> <write><data>10 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?69 B ></pcre></match></read> <write><data>18 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?70 B ></pcre></match></read> <write><data>7 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?71 B ></pcre></match></read> <write><data>13 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?72 B ></pcre></match></read> <write><data>6 16\\x0a</data></write> <read><delim>\\x3e</del"}
{"text": "2 * Java Class Version: 6 (50.0) * JD-Core Version: 0.7.1 */<s><start> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- * vim: set ts=4 sw=4 et tw=99: * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0/LGPL 2.1 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the \"License\"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an \"AS IS\" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released * May 28, 2008. * * The Initial Developer of the Original Code is * Brendan Eich <brendan@mozilla.org> * * Contributor(s): * David Anderson <danderson@mozilla.com> * David Mandelin <dmandelin@mozilla.com> * * Alternatively, the contents of this file may be used under the terms of * either of the GNU General Public License Version 2 or later (the \"GPL\"), * or the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"), * in which case the provisions of the GPL or the LGPL are applicable instead * of those above. If you wish to allow use of your version of this file only * under the terms of either the GPL or the LGPL, and not to allow others to * use your version of this file under the terms of the MPL, indicate your * decision by deleting the provisions above and replace them with the notice * and other provisions required by the GPL or the LGPL. If you do not delete * the provisions above, a recipient may use your version of this"}
{"text": "im><match><pcre>.*?72 B ></pcre></match></read> <write><data>9 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?73 B ></pcre></match></read> <write><data>6 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?74 B ></pcre></match></read> <write><data>10 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?75 B ></pcre></match></read> <write><data>8 4\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?75 B ></pcre></match></read> <write><data>8 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?76 B ></pcre></match></read> <write><data>10 2\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?76 B ></pcre></match></read> <write><data>pass\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?77 B ></pcre></match></read> <write><data>19 19\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?77 B ></pcre></match></read> <write><data>1 0\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?77 B ></pcre></match></read> <write><data>12 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?78 B ></p"}
{"text": "file under * the terms of any one of the MPL, the GPL or the LGPL. * * ***** END LICENSE BLOCK ***** */ #if !defined jsjaeger_methodjit_inl_h__ && defined JS_METHODJIT #define jsjaeger_methodjit_inl_h__ namespace js { namespace mjit { enum CompileRequest { CompileRequest_Interpreter, CompileRequest_JIT }; /* Number of times a script must be called before we run it in the methodjit. */ static const size_t CALLS_BEFORE_COMPILE = 16; /* Number of loop back-edges we execute in the interpreter before methodjitting. */ static const size_t BACKEDGES_BEFORE_COMPILE = 16; static inline CompileStatus CanMethodJIT(JSContext *cx, JSScript *script, JSStackFrame *fp, CompileRequest request) { if (!cx->methodJitEnabled) return Compile_Abort; JITScriptStatus status = script->getJITStatus(fp->isConstructing()); if (status == JITScript_Invalid) return Compile_Abort; if (request == CompileRequest_Interpreter && status == JITScript_None && !cx->hasRunOption(JSOPTION_METHODJIT_ALWAYS) && script->incCallCount() <= CALLS_BEFORE_COMPILE) { return Compile_Skipped; } if (status == JITScript_None) return TryCompile(cx, fp); return Compile_Okay; } /* * Called from a backedge in the interpreter to decide if we should transition to the * methodjit. If so, we compile the given function. */ static inline CompileStatus CanMethodJITAtBranch(JSContext *cx, JSScript *script, JSStackFrame *fp, jsbytecode *pc) { if (!cx->methodJitEnabled) return Compile_Abort; JITScriptStatus status = script->getJITStatus(fp->isConstructing()); if (status == JITScript_Invalid) return Compile_Abort; if (status == JITScript_None && !cx->"}
{"text": "cre></match></read> <write><data>5 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?78 B ></pcre></match></read> <write><data>2 11\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?79 B ></pcre></match></read> <write><data>3 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?80 B ></pcre></match></read> <write><data>18 0\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?80 B ></pcre></match></read> <write><data>1 13\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?80 B ></pcre></match></read> <write><data>10 4\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?80 B ></pcre></match></read> <write><data>19 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?80 B ></pcre></match></read> <write><data>13 18\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?81 B ></pcre></match></read> <write><data>18 5\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?82 B ></pcre></match></read> <write><data>16 5\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?82 B ></pcre></match></read> <write><data>1"}
{"text": "hasRunOption(JSOPTION_METHODJIT_ALWAYS) && cx->compartment->incBackEdgeCount(pc) <= BACKEDGES_BEFORE_COMPILE) { return Compile_Skipped; } if (status == JITScript_None) return TryCompile(cx, fp); return Compile_Okay; } } } #endif<s><start> // Code generated by go-swagger; DO NOT EDIT. package models // This file was generated by the swagger tool. // Editing this file might prove futile when you re-run the swagger generate command import ( \"github.com/go-openapi/errors\" \"github.com/go-openapi/strfmt\" \"github.com/go-openapi/swag\" \"github.com/go-openapi/validate\" ) // RegistrationViaAPIResponse The Response for Registration Flows via API // // swagger:model registrationViaApiResponse type RegistrationViaAPIResponse struct { // identity // Required: true Identity *Identity `json:\"identity\"` // session Session *Session `json:\"session,omitempty\"` // The Session Token // // This field is only set when the session hook is configured as a post-registration hook. // // A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization // Header: // // Authorization: bearer ${session-token} // // The session token is only issued for API flows, not for Browser flows! // Required: true SessionToken *string `json:\"session_token\"` } // Validate validates this registration via Api response func (m *RegistrationViaAPIResponse) Validate(formats strfmt.Registry) error { var res []error if err := m.validateIdentity(formats); err != nil { res = append(res, err) } if err := m.validateSession(formats); err != nil { res = append(res, err) } if err := m.validateSessionToken(formats); err != nil { res = append(res, err) } if len(res) > 0 { return errors.CompositeValidationError(res...) } return nil } func (m *RegistrationViaAPIResponse) validateIdentity(formats strfmt.Registry) error { if err := validate.Required"}
{"text": "2 15\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?83 B ></pcre></match></read> <write><data>0 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?84 B ></pcre></match></read> <write><data>4 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?85 B ></pcre></match></read> <write><data>16 16\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?86 B ></pcre></match></read> <write><data>12 3\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?86 B ></pcre></match></read> <write><data>0 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?86 B ></pcre></match></read> <write><data>19 4\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?86 B ></pcre></match></read> <write><data>7 10\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?87 B ></pcre></match></read> <write><data>15 17\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?88 B ></pcre></match></read> <write><data>4 19\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?88 B ></pcre></match></read> <write><data>10 16\\x0a</"}
{"text": "(\"identity\", \"body\", m.Identity); err != nil { return err } if m.Identity != nil { if err := m.Identity.Validate(formats); err != nil { if ve, ok := err.(*errors.Validation); ok { return ve.ValidateName(\"identity\") } return err } } return nil } func (m *RegistrationViaAPIResponse) validateSession(formats strfmt.Registry) error { if swag.IsZero(m.Session) { // not required return nil } if m.Session != nil { if err := m.Session.Validate(formats); err != nil { if ve, ok := err.(*errors.Validation); ok { return ve.ValidateName(\"session\") } return err } } return nil } func (m *RegistrationViaAPIResponse) validateSessionToken(formats strfmt.Registry) error { if err := validate.Required(\"session_token\", \"body\", m.SessionToken); err != nil { return err } return nil } // MarshalBinary interface implementation func (m *RegistrationViaAPIResponse) MarshalBinary() ([]byte, error) { if m == nil { return nil, nil } return swag.WriteJSON(m) } // UnmarshalBinary interface implementation func (m *RegistrationViaAPIResponse) UnmarshalBinary(b []byte) error { var res RegistrationViaAPIResponse if err := swag.ReadJSON(b, &res); err != nil { return err } *m = res return nil }<s><start> s [ ] w [a-z0-9A-Z] W [^a-z0-9A-Z] d [0-9] %% ((MERGE.*USING{s}*\\()|(EXECUTE{s}*IMMEDIATE{s}*\\\")|({W}+{d}{s}+HAVING{s}+{d})|(MATCH{s}*[a-zA-Z\\\\(\\\\),+\\-]+{s}*AGAINST{s}*\\()) printf('attack detected'); %%<s><start> PREFIX dc: <http://purl.org/dc/elements/1.1/> PREFIX ns: <http://example.org/ns#> SELECT ?title ?price { ?x ns:price ?p ."}
{"text": "data></write> <read><delim>\\x3e</delim><match><pcre>.*?89 B ></pcre></match></read> <write><data>7 14\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?89 B ></pcre></match></read> <write><data>3 1\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?89 B ></pcre></match></read> <write><data>1 7\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?90 B ></pcre></match></read> <write><data>17 6\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?90 B ></pcre></match></read> <write><data>19 15\\x0a</data></write> <read><delim>\\x3e</delim><match><pcre>.*?90 B ></pcre></match></read> <write><data>8 11\\x0a</data></write> <read><delim>User</delim><match><pcre>.*?Game Over Stones Exhausted You are a Winner, User</pcre></match></read> </replay> </pov><s><start> /** * Copyright (c) 2015-present, Facebook, Inc. All rights reserved. * * You are hereby granted a non-exclusive, worldwide, royalty-free license to * use, copy, modify, and distribute this software in source code or binary * form for use in connection with the web services and APIs provided by * Facebook. * * As with any software that integrates with the Facebook platform, your use * of this software is subject to the Facebook Developer Principles and * Policies [http://developers.facebook.com/policy/]. This copyright notice * shall be included in all copies or substantial portions of the software. * * THE SOFTWARE IS PROVIDED \"AS IS"}
{"text": "?x ns:discount ?discount BIND (?p*(1-?discount) AS ?price) FILTER(?price < 20) ?x dc:title ?title . }<s><start> package volumes var _ ResizeService = (*LinuxResizeService)(nil)<s><start> /* * TupleTypeUtil.java * * This source file is part of the FoundationDB open source project * * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.apple.foundationdb.record.metadata; import com.apple.foundationdb.record.provider.foundationdb.FDBRecordVersion; import com.apple.foundationdb.tuple.Tuple; import com.google.protobuf.ByteString; import com.google.protobuf.Descriptors; import com.google.protobuf.ProtocolMessageEnum; import javax.annotation.Nonnull; import javax.annotation.Nullable; import java.math.BigInteger; import java.util.ArrayList; import java.util.List; /** * Utility class for dealing with {@link Tuple} types. In theory, these methods should live in * {@link com.apple.foundationdb.tuple.TupleHelpers TupleHelpers} except that they use some Protobuf specific things * like the {@link ByteString} class, and {@code TupleHelpers} is defined in the * <a href=\"https://javadoc.io/doc/org.foundationdb/fdb-extensions/\">fdb-extensions</a> sub-project * which does not (and probably should not) take Protobuf as a dependency. */ class TupleType"}
{"text": "\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. * */ package com.facebook.ads.sdk; import java.io.File; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map; import com.google.common.base.Function; import com.google.common.util.concurrent.Futures; import com.google.common.util.concurrent.ListenableFuture; import com.google.common.util.concurrent.SettableFuture; import com.google.gson.JsonObject; import com.google.gson.JsonArray; import com.google.gson.annotations.SerializedName; import com.google.gson.reflect.TypeToken; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.google.gson.JsonElement; import com.google.gson.JsonParser; import com.facebook.ads.sdk.APIException.MalformedResponseException; /** * This class is auto-generated. * * For any issues or feature requests related to this class, please let us know * on github and we'll fix in our codegen framework. We'll not be able to accept * pull request for this class. * */ public class Flight extends APINode { @SerializedName(\"applinks\") private CatalogItemAppLinks mApplinks = null; @SerializedName(\"category_specific"}
{"text": "Util { @Nonnull private static final BigInteger BIG_INT_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE); @Nonnull private static final BigInteger BIG_INT_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE); /** * Normalize a list of values so that it can be checked for equality with other lists sharing * the same {@link Tuple} representation. In other words, it should be the case that: * * <pre> {@code * toTupleEquivalentValue(list1).equals(toTupleEquivalentValue) * == Arrays.equals(Tuple.fromList(toTupleAppropriateList(list1)).pack(), Tuple.fromList(toTupleAppropriateList(list2)).pack()) * }</pre> * * <p> * for any two lists {@code list1} and {@code list2}. * </p> * * @param values the list of values to normalized * @return a new list containing the normalized elements of {@code values} */ @Nonnull static List<Object> toTupleEquivalentList(@Nonnull List<?> values) { List<Object> tupleEquivalentList = new ArrayList<>(values.size()); for (Object o : values) { tupleEquivalentList.add(toTupleEquivalentValue(o)); } return tupleEquivalentList; } /** * Normalize a value so that it compares equal to anything with the same {@link Tuple} representation. * The value that is returned cannot necessarily be packed by a {@code Tuple} (for example, * a <code>byte[]</code> is returned as a {@link ByteString}), but it does implement {@link Object#equals(Object)} * and {@link Object#hashCode()}, so the value can be used in hash-based data structures like * {@link java.util.HashSet HashSet}s and {@link java.util.HashMap HashMap}s. In other words, it should * bethe case that: * * <pre> {@code * Objects.equals(toTupleEquivalentValue(value1), toTupleEquivalentValue(value2)) * == Arrays.equals(Tuple.from(value1).pack(), Tuple.from(value2).pack()) * }</pre> * *"}
{"text": "_fields\") private CatalogSubVerticalList mCategorySpecificFields = null; @SerializedName(\"currency\") private String mCurrency = null; @SerializedName(\"description\") private String mDescription = null; @SerializedName(\"destination_airport\") private String mDestinationAirport = null; @SerializedName(\"destination_city\") private String mDestinationCity = null; @SerializedName(\"flight_id\") private String mFlightId = null; @SerializedName(\"id\") private String mId = null; @SerializedName(\"images\") private List<String> mImages = null; @SerializedName(\"oneway_currency\") private String mOnewayCurrency = null; @SerializedName(\"oneway_price\") private String mOnewayPrice = null; @SerializedName(\"origin_airport\") private String mOriginAirport = null; @SerializedName(\"origin_city\") private String mOriginCity = null; @SerializedName(\"price\") private String mPrice = null; @SerializedName(\"sanitized_images\") private List<String> mSanitizedImages = null; @SerializedName(\"url\") private String mUrl = null; protected static Gson gson = null; Flight() { } public Flight(Long id, APIContext context) { this(id.toString(), context); } public Flight(String id, APIContext context) { this.mId = id; this.context = context; } public Flight fetch() throws APIException{ Flight newInstance = fetchById(this.getPrefixedId().toString(), this.context); this.copyFrom(newInstance); return this; } public static Flight fetchById(Long id, APIContext context) throws APIException { return fetchById(id.toString(), context); } public static ListenableFuture<Flight> fetchByIdAsync(Long id, APIContext context) throws APIException { return fetchByIdAsync(id.toString(), context); } public static Flight fetchById(String id, APIContext context) throws APIException { return new APIRequestGet(id, context) .requestAllFields() .execute(); } public static ListenableFuture<Flight> fetchByIdAsync(String id, APIContext context) throws APIException { return new APIRequestGet(id, context) .requestAllFields() .executeAsync();"}
{"text": "<p> * for any two values {@code value1} and {@code value2}. * </p> * * <p> * This will only return {@code null} if {@link #toTupleAppropriateValue(Object)} would return {@code null} * on the same input. If the object is already in * </p> * * @param obj the value to normalize * @return a value that has the same representation when {@link Tuple}-encoded */ @Nullable static Object toTupleEquivalentValue(@Nullable Object obj) { if (obj == null || obj instanceof Key.Evaluated.NullStandin) { return null; } else if (obj instanceof List<?>) { List<?> list = (List<?>)obj; return toTupleEquivalentList(list); } else if (obj instanceof Tuple) { return toTupleEquivalentList(((Tuple)obj).getItems()); } else if (obj instanceof byte[]) { return ByteString.copyFrom((byte[]) obj); } else if ((obj instanceof Byte) || (obj instanceof Short) || (obj instanceof Integer)) { return ((Number)obj).longValue(); } else if (obj instanceof BigInteger) { BigInteger bigInt = (BigInteger)obj; if (bigInt.compareTo(BIG_INT_MIN_LONG) > 0 && bigInt.compareTo(BIG_INT_MAX_LONG) < 0) { return bigInt.longValue(); } else { return bigInt; } } else if (obj instanceof ProtocolMessageEnum) { return (long)((ProtocolMessageEnum)obj).getNumber(); } else if (obj instanceof Descriptors.EnumValueDescriptor) { return (long)((Descriptors.EnumValueDescriptor)obj).getNumber(); } else if (obj instanceof FDBRecordVersion) { return ((FDBRecordVersion)obj).toVersionstamp(false); } else { return obj; } } /** * Convert a list of values into items that can all be stored within a {@link Tuple}. * * @param values a list of values * @return a new list with {@link Tuple}-encodable versions of the elements of {@code values} */ @Nonnull static List<Object> toTupleAppropriateList(@Nonnull List<?> values) { List<Object> tupleAppropriate"}
{"text": "} public static APINodeList<Flight> fetchByIds(List<String> ids, List<String> fields, APIContext context) throws APIException { return (APINodeList<Flight>)( new APIRequest<Flight>(context, \"\", \"/\", \"GET\", Flight.getParser()) .setParam(\"ids\", APIRequest.joinStringList(ids)) .requestFields(fields) .execute() ); } public static ListenableFuture<APINodeList<Flight>> fetchByIdsAsync(List<String> ids, List<String> fields, APIContext context) throws APIException { return new APIRequest(context, \"\", \"/\", \"GET\", Flight.getParser()) .setParam(\"ids\", APIRequest.joinStringList(ids)) .requestFields(fields) .executeAsyncBase(); } private String getPrefixedId() { return getId(); } public String getId() { return getFieldId().toString(); } public static Flight loadJSON(String json, APIContext context, String header) { Flight flight = getGson().fromJson(json, Flight.class); if (context.isDebug()) { JsonParser parser = new JsonParser(); JsonElement o1 = parser.parse(json); JsonElement o2 = parser.parse(flight.toString()); if (o1.getAsJsonObject().get(\"__fb_trace_id__\") != null) { o2.getAsJsonObject().add(\"__fb_trace_id__\", o1.getAsJsonObject().get(\"__fb_trace_id__\")); } if (!o1.equals(o2)) { context.log(\"[Warning] When parsing response, object is not consistent with JSON:\"); context.log(\"[JSON]\" + o1); context.log(\"[Object]\" + o2); } } flight.context = context; flight.rawValue = json; flight.header = header; return flight; } public static APINodeList<Flight> parseResponse(String json, APIContext context, APIRequest request, String header) throws MalformedResponseException { APINodeList<Flight> flights = new APINodeList<Flight>(request, json, header); JsonArray arr; JsonObject obj; JsonParser parser = new JsonParser(); Exception exception = null; try{ JsonElement result = parser.parse(json);"}
